# Ch13. 컴퓨터 보안

## 보안과 프라이버시 개요

### 위협 모델

위협(threat)이 없다면 보안을 논할 이유가 없다. 보안은 `위협 모델(threat model)`에 따라 상대적이다.
위협 모델은 보안이 필요한 대상 목록과 각 보안 대상에 가해질 수 있는 공격을 열거해서 이런 공격을 방어하는 방법을 설계할 수 있게 한다.

100% 보안은 존재하지 않기 때문에 위협 모델을 이해하고 위협 모델에 따라 적합한 방어를 설계해야 한다.
예를 들어, 학교에서 학용품이나 가방을 보관하기 위한 수단이 필요하다고 하자. 학생마다 경비원을 고용하는 대신 사물함을 사용하는 것이 적합하다.

간혹 보안을 해치는 경우도 있다. 예를 들어, 많은 기업들은 패스워드 조합 방법과 패스워드 변경을 주기적으로 유도한다. 이로 인해 사용자들은 쉽게 추측할 수 있는 패턴의 패스워드를 사용하거나 어디 저장해두기도 한다.

위협 모델을 정의하지 않으면 효과적으로 보안을 강화할 수 없다. 위협과 위협에 대비한 방어 사이에 균형을 맞춰야 한다.
목표는 공격자가 통과하려면 비싸지만 방어자에게는 비용이 적게 드는 방어를 사용하는 것이다.

<br></br>

### 신뢰

위협 모델을 정의할 때 가장 어려운 것은 `신뢰(trust)할 대상`을 정하는 것이다.
인간 관계에서는 직접 만나거나 상호작용을 통해 상대를 신뢰할 수 있는지 사람이 판단할 수 있다.
하지만 와이파이 액세스 포인트를 신뢰할 수 있는지는 동일하게 판단할 수 없다.

또한, 제어할 수 없는 대상을 신뢰할 때마다 보안은 감소한다. 비밀을 털어 놓는 친구가 늘어날 때마다 비밀이 알려질 확률이 더 높아지는 것과 같다.
즉, 처음 신뢰를 하는 순간부터 보안은 나빠지고, 신뢰할 대상을 추가할수록 보안은 더 악화된다.

컴퓨터 보안 세계에서 '신뢰'라는 것은 사람이 선택할 수는 없지만, 의존해야 하는 대상을 가리키는 말이기도 하다.
보안을 아주 높이기 위해서는 꼭 필요한 대상만으로 신뢰를 최소화해야 한다. 컴퓨터를 사용하거나 개발을 하다보면, 수많은 서드파티(third-party) 하드웨어나 소프트웨어에 의존해야 한다.
이런 하드웨어안 소프트웨어의 설계도나 소스 코드를 볼 수는 없지만 의존하지 않을 수도 없다.

<br/>

> 3가지 유형의 신뢰 위반

1. `의도적(deliberate)`

   SONY가 고객의 컴퓨터에 설치했던 시스템 보호를 우회하는 소프트웨어 모음(루트킷\_rootkit)이나 Levono가 랩탑에 설치했던 광고 표시 멀웨어처럼 컴퓨터 제조사가 의도적으로 설치한 프로그램을 예시로 들 수 있다.

2. `무능(incompetent)`

   암호화가 되지 않은 대상들이다. 또는, 과거 지멘스와 시스코의 예시로 패스워드가 하드코딩 된 사례가 있다.

3. `부정직(disingenuous)`

   거짓말하는 것을 말한다. 과거 미국 국립 표준 기술 연구소에서 미국 국가안보국의 전문가들의 도움으로 암호 표준을 만들었는데, 나중에 의도적으로 표준을 강화하지 않고 약화시켰던 것이다.
   이로 인해, 스파이 활동이 더 쉬워졌고 은행 계정 보안도 더 약해졌다.

`모호성에 의한 보안`이라는 말은 비밀의 근원이 모호하면 보호 대상이 더 안전하다는 식의 주장이다. 하지만 역사 속에서 여러 가지 사건을 통해 실제로는 그렇지 않다는 사실이 드러났다.
또한, 암호를 사용해서 안전하다고 생각하지만, 사용자도 모르게 암호화되지 않은 정보를 빼낼 수 있게 하는 여러 수단을 `클렙토그래피(kleptography)`라고 한다.

<br></br>

### 물리적 보안

- `공격 표면(attack surface)`

  다시 학교 사물함을 예시로 들자면, 사물 안에 소지품에 접근하기 위해 공격자들이 노리는 대상은 사물함의 문이므로 사물함 문을 공격 표면이라고 부른다.

- `권한 부여(authorization)`

  사물함에 달린 자물쇠의 비밀번호를 안다는 것은 해당 사물함을 열 수 있도록 권한(privilege)을 부여받은 것이라고 할 수 있다. 여기서 자물쇠가 일종의 또 다른 공격 표면이라고 할 수 있다.

- `백 도어(back-door)`

  사물함 자물쇠 가운데에는 보통 열쇠 구멍이 있다. 이를 백 도어라고 하며, 이또한 하나의 공격 표면이기도 하다.
  이 구멍은 모든 사물함을 빠르게 열 수 있도록 편의상 만든 것이지만, 이로 인해 보안은 더 약화된다. 여기서 자물쇠 비밀번호 뿐만 아니라, 이 열쇠를 갖고 있는 사람은 더 높은 권한 수준을 갖는다고 표현할 수 있다.

<br></br>

### 통신 보안

앞에서는 물리적인 보안을 다루었다. 하지만 네트워크처럼 통신상의 보안도 필요하다.

학교 생활을 예시로, 친구를 통해 누군가에게 물건을 전달한다고 가정한다.

- `인증(authentication)`

  첫 번째 단계이다. 물건을 전달해 줄 매개자가 본인이 알고 있는 친구인지 확인하는 과정이다. 여기서 친구를 흉내내거나 속이는 것이 공격 표면이 될 수 있다.

- `진본성(authenticity)`

  물건을 전달할 매개자가 인증되어도, 의도한대로 잘 전달할지는 미지수이다. 물건이 파손될 수도 있고 다른 물건이 될 수도 있다.

- `중간자 공격(man-in-the-middle attack)`

  중간에 공격자가 들어가서 통신을 가로채거나 변경하는 상황이다. 불특정 신원의 대상이 중간자 공격을 취하면 인증할 수 있는 기회도 없다.

- `크립토그래피(cryptography)`

  위와 같은 상황에서 해결책은 크립토그래피이다. 송신자와 수신자만 아는 비밀 코드를 사용해 `암호화(encrypt)`해서 보내면 수신자는 비밀 코드를 사용해 암호화된 메시지를 `복호화(decrypt)`한다.
  이 비밀 코드는 비밀로 유지되어야 하며, 제대로 설계된 암호 시스템은 당사자 사이에 신뢰하는 요소의 수를 감소시킨다.

<br></br>

### 인증(Authentication)과 인가(Authorization)의 차이

|               -                |         인증(Authentication)          |         인가(Authorization)         |
| :----------------------------: | :-----------------------------------: | :---------------------------------: |
|              기능              |            자격 증명 확인             |           권한 허가/거부            |
|           진행 방식            | 비밀번호, 생체인식, 일회용 핀 또는 앱 | 보안 관리 주체가 관리하는 설정 사용 |
|     사용자가 볼 수 있는가      |                   O                   |                  X                  |
| 사용자가 직접 변경할 수 있는가 |            부분적으로 가능            |               불가능                |
|          데이터 전송           |             ID 토큰 사용              |          액세스 토근 사용           |

<br></br>

### 참고 자료

- [인증과 인가 (권한 부여) 비교 – 특징 및 차이점](https://www.okta.com/kr/identity-101/authentication-vs-authorization/)
- [Authentication vs Authorization](https://auth0.com/intro-to-iam/authentication-vs-authorization/)

## 보안과 프라이버시 개요 (2)

<br>

### `모던타임즈`

<br>

`연결된 컴퓨터` 시대는 물리적 보안 문제를 통신 보안 문제와 결합시켰다.
문제를 일으키기 위해 공격자가 꼭 어떤 기계에 들어갈 필요도 없다.

초인종을 누르는 사람이 충분히 지속성이 있다면 이들로 인해 다른 사람이 여러분의 대문 초인종을 누르지 못할 수도 있다.
정당한 고객들이 서비스를 받지 못하게 방해하기 때문에,

이런 형태의 공격을 `서비스 거부 (DoS, Denial of Service)공격`이라고 부른다.

오늘날 이런 식의 공격은 대부분 `분산 서비스 거부 공격(DDoS, Distributed Denial of Service)`으로 이뤄진다.

공격자의 추적을 아주 어렵게 하는 요인 중 하나는 공격자가 `프록시`를 사용한다는 점이다.
공격자들은 몇몇 기계에 침입해서 자신의 소프트웨어(`멀웨어`)를 설치하고 이 다른 기계들이 더러운 일을 하게 한다.

일반적인 공격은 트릭을 써서 사용자가 자신의 컴퓨터에 소프트웨어를 직접 설치하게 만드는 `사회적`공격이다. (네이버 로그인 피싱 등)

현대에는 `IoT`와 `로보틱스`의 등장으로 인해 공격자가 진공청소기를 프로그램해서 침입 경보기를 끄거나 겨울에 보일러를 꺼서 수도관을 동파시키는 일이 가능해졌다.

또 `딥페이크`라는 사실적은 사진, 오디오, 비디오를 만들어내기가 쉬워졌고, 미래에는 우리의 목소리가 범죄에 사용될 인공지능 목소리로 변환되는 등의 범죄가 일어날 수 있다.

ex) 그 외 현대 기술 보안공격의 예

- `공급망 공격`

  주 52시간 근무제로 재택근무, 원격지 근무, 모바일 근무자가 늘어나고 있으며, 원격 접속 환경을 이용하는 공급망 공격도 우려된다. 재택근무자가 보안관리가 되지 않은 가정 내 공유 단말을 이용해 접속할 때 특히 위험하다

- `클라우드 보안`

  클라우드 보안위협은 앞으로 더 심각한 문제로 대두될 것으로 보인다. 클라우드 속도와 효율성을 높이기 위한 새로운 기술이 봇물 터지듯 쏟아져나오고 있는데, 이 기술이 가진 취약점이나 보안 약점에 대해서는 아직 충분히 논의되지 않은 상황이다.

- `데이터 보안`

  사이버 보안의 궁극적인 목표는 ‘데이터 보호’다. 공격자는 모든 종류의 데이터를 탈취해 수익을 얻는다. 공격자의 수익원이 되는 데이터를 빼앗기지 않으면 피해도 일어나지 않는다. 데이터 유출로 인한 피해가 극심한데도 데이터 보호는 여전히 소홀하다. 중요 데이터를 암호화하지 않고 클라우드로 보내거나 암호화한 후 키와 함께 클라우드에 저장하고, 클라우드 계정을 관리하지 않고 방치해 정상 권한을 가진 계정으로 공격자가 침투해 데이터를 가져간다.

- `랜섬웨어`
- 몸값을 뜻하는 Ransom과 악성 코드를 뜻하는 Malware의 합성어이며, 사용자의 동의 없이 시스템에 설치되어서 무단으로 사용자의 파일을 모두 암호화하여 인질로 잡고 금전을 요구하는 악성 프로그램을 말한다. 일반적인 PC는 물론 서버, 모바일, DSLR에서까지 현존하는 거의 모든 운영체제에서 활동한다. 랜섬웨어 종류에 따라 백신 프로그램이 사전에 랜섬웨어의 암호화를 차단하기도 한다

<br>

### `메타데이터와 감시`

<br>
현대 기술이 가져올 큰 변화 중 하나는 암호화가 통신 내용을 비밀로 유지할 수 있다고 해도, 단지 통신 패턴을 관찰하는 것만으로도 많은 정보를 얻을 수 있다.

<br>

> 요기 베라(Yogi Berra) - "보고 있는 것만으로도 많은 것을 관찰할 수 있다."

<br>

`메타데이터`란 우편봉투에 적혀진 내용처럼 데이터에 대한 데이터를 의미한다. 누군가는 이 정보를 사용해 네트워크를 알아낼 수 있다. 현대에서는 이 말이 그리 나쁜 말로 들리지 않을 수도 있는데, SNS를 통해 더 다양한 정보를 취득할 수 있기 때문이다.
그리고 핸드폰을 들고 다니면 또 다른 메타데이터인 휴대전화 시스템 정보를 가지고 우리를 추적할 수 있다.

<br>

### `인증과 권한부여`

`인증(authentication)`: 어떤 사람이나 대상이 실제로 그 사람이나 대상임을 증명하는 과정

`권한부여(authorization)` 제대로된 '자격증명(credential)'을 제공하지 않는 사람에게 접근을 제한하는 것

이 두 가지 중에서는 분명 권한부여가 더 쉽다. 권한부여는 제대로 설계하고 구현한 하드웨어와 소프트웨어로 해결이 가능하다. 인증은 훨씬 어렵다. 소프트웨어는 패스워드를 입력한 사람이 여러분인지 다른 사람인지 어떻게 구분할 수 있을까?

요즘 많은 시스템에서 `2단계 인증(2FA, two-factor authentication)`을 사용한다. 여기서 `단계`란 독립적인 검증 수단을 뜻한다. 한 단계는 여러분을 유일하게 구분할 수 있는 요소(지문 등)이거나 여러분만 알 수 있는 내용(패스워드나 PIN)을 포함한다. 따라서 2단계 인증은 이런 요소를 두 가지 사용한다.

Ex) 여러가지 단계별 인증 예시

- 이메일 인증
- 1원 입금 후 해당 문자 입력 (금융권에서 주로 사용)
- 문자메세지를 통한 인증번호 입력
- OTP(One Time Password)
- Yubikey 등의 물리적인 보안키

### 참고

- [[사이버 공격 동향②] 최신 보안 기술 역이용하는 공격자](http://www.datanet.co.kr/news/articleView.html?idxno=139715)
- [“로그인 했는데 또 하라고?”…‘가짜 네이버 사이트’ 주의보](https://www.hankookilbo.com/News/Read/202001171207346420)
- [랜섬웨어 - 나무위키](https://namu.wiki/w/%EB%9E%9C%EC%84%AC%EC%9B%A8%EC%96%B4)
- [2단계 인증 - 나무위키](https://namu.wiki/w/2%EB%8B%A8%EA%B3%84%20%EC%9D%B8%EC%A6%9D)

# 크립토그래피

### 스테가노그래피

기밀 정보를 이미지 파일이나 MP3 파일 등에 암호화 해 숨기는 기술  
숨긴 방식을 모르면 제 3자가 알아차리기 힘들다.  
기존 파일 안에 기밀 파일을 숨기는 형태로 용량이 부풀어 의심을 살 수 있다.

### 치환 암호

어떠한 문자를 다른 문자로 대체해 만드는 암호(cipher)  
<img width="273" alt="123123" src="https://user-images.githubusercontent.com/91672778/185752076-e23eb7c3-c6a7-443f-bdf5-06d1a9f56927.png">  
암호화(encrypt) <=> 복호화(decrypt)  
평문(plaintext) <=> 암호문(ciphertext)

### 전치 암호

평문의 순서를 특별한 절차에 따라 재배치해 만드는 암호

![1212](https://user-images.githubusercontent.com/91672778/185752543-6fbbb413-9cf0-4abc-9210-7aff032ca7e9.png)

### 대칭 키 암호

둘 이상의 사용자 사이에 공유된 단일 키를 기반으로 평문을 암호화 하고 해독하는 암호  
cipher라 불리는 암호화 알고리즘에 평문을 실행하는 것으로 구성되며 이는 암호문을 생성한다.  
대응하는 키를 무작위로 추측해 대입하기 얼마나 어려운지에 따라 보안이 결정된다.  
대표적으로 `AES`

자바스크립트 crypto aes-256-gcm 알고리즘 예시

```
const encrypt = (text: string, secret_key: string): string => {
  const iv = randomBytes(16)
  const cipher: CipherGCM = createCipheriv('aes-256-gcm', secret_key, iv)

  const encrypted = cipher.update(text, 'utf-8')
  const final = cipher.final()
  return Buffer.concat([encrypted, final, iv, cipher.getAuthTag()]).toString(
    'base64'
  )
}

const decrypt = (text: string, secret_key: string): string => {
  const text_to_buffer = Buffer.from(text, 'base64')
  const iv = text_to_buffer.slice(
    text_to_buffer.length - 32,
    text_to_buffer.length - 16
  )
  const auth_tag = text_to_buffer.slice(text_to_buffer.length - 16)
  const encrypted = text_to_buffer.slice(0, text_to_buffer.length - 32)

  const decipher: DecipherGCM = createDecipheriv(
    'aes-256-gcm',
    secret_key,
    iv
  )
  decipher.setAuthTag(auth_tag)
  const decrypted = decipher.update(encrypted, null, 'utf-8')

  return decrypted + decipher.final('utf-8')
}
```

### 공개 키 암호

누구에게나 알려져 있는 키(공개키,public key)와 본인만 알고 있는 키(비밀키,private key)를 이용해  
공개키로 암호화한 암호문은 비밀키로만 복호화 할 수 있다.

`트랩도어 함수` 한 방향으로는 계산이 쉽지만 반대 방향으로는 계산이 어려운 문제

`RSA`  
초창기 비대칭 키 암호  
사용자는 임의의 큰 소수 두 개를 골라 비밀 키로 삼고 그 곱한 값을 공개키로 공개  
큰 수의 소인수 분해는 굉장히 오랜 시간이 걸리는 점을 이용

### 참고자료

- [해시넷 위키 - 스테가노그래피](http://wiki.hash.kr/index.php/%EC%8A%A4%ED%85%8C%EA%B0%80%EB%85%B8%EA%B7%B8%EB%9E%98%ED%94%BC)
- [사진 속에 비밀 텍스트나 파일 숨기기 - 스테가노그래피(Steganography) 기법](https://s2ecure.tistory.com/entry/%EC%82%AC%EC%A7%84-%EC%86%8D%EC%97%90-%EB%B9%84%EB%B0%80-%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%82%98-%ED%8C%8C%EC%9D%BC-%EC%88%A8%EA%B8%B0%EA%B8%B0-%EC%8A%A4%ED%85%8C%EA%B0%80%EB%85%B8%EA%B7%B8%EB%9E%98%ED%94%BCSteganography-%EA%B8%B0%EB%B2%95)

## 암호학적 해시 함수

<br/>

암호학적 해시 함수의 특징은 `단방향` 함수라는 점이다.  
입력에서 해시값을 만들어내기는 쉬워도, 해시에서 입력을 만들어낼 수 없거나 만들기 굉장히 어렵다.

다른 특징 중 하나는,  
차이가 조금!있는 여러 입력 데이터에 암호학적 해시 함수를 적용해 만든 해시값들은 서로 연관 관계가 없어 보여야 한다는 점이다.

암호학적 해시 함수는 도용이 아주 어렵게 설계되어야 한다.  
해시가 주어져도 그 해시를 만들어낸 입력데이터를 예측할 수 없게 해야한다.

2020년 기준으로 우리는 SHA 알고리즘을 변형한 해시 알고리즘을 사용하고 있다.

<br/>

## 디지털 서명

<br/>

크립토그래피를 사용하면, 디지털 서명을 통해 데이터가 진본임을 검증할 수 있다.  
디지털 서명은 `정합성` / `부인 방지` / `인증 기능`을 제공한다.

`정합성`  
메세지가 변조되었는지, 원본인지 검증할 수 있다는 뜻이다.  
정합성 검증은 데이터의 암호학적 해시값을 계산해 데이터 뒤에 추가함으로써 이뤄진다.  
송신자 누구나 메세지 뒤에 아무 해시나 붙여서 보낼 수 있으므로, 자신의 비밀키로 암호화한 해시를 덧붙여 전송한다.  
수신자는 공개키를 통해 해시를 복호화 할 수 있다.

```
*서명* 의 경우 공개키와 비밀키의 역할이 반대이다.
공개키 암호화 시스템에서 공개키로 암호화한 정보를 비밀키로 해제하는 것은 *항상* 가능하지만,
비밀키로 암호화한 정보를 공개키로 해제하는 것은 항상 가능하진 않다.
RSA나 요즘 블록체인 기술에서 자주 사용되는 `elliptic curve cryptography(타원 곡선 암호)` 는 양방향으로 암호화와 복호화가 가능하다.
이러한 암호 시스템만 서명에 사용할 수 있다.
```

`부인 방지`  
비밀키를 사용하기 때문에, 메세지를 보낸 사람이 자신이 서명했음을 부인하기가 어렵다.

`인증`  
수신자는 공개키와 서명한 사람의 비밀키가 연관이 있음을 알고 있기 때문에 메세지에 서명한 사람을 확신할 수 있고,  
변조가 되지 않았음은 해시값으로부터 확인할 수 있기때문에 수신자가 받은 메세지가 원본과 같은 메세지임을 확인할 수 있다.

<br/>

## 공개키 인프라

<br/>

공개키 암호화를 사용했을 때 생길 수 있는 문제를 예시로 살펴보자.  
웹 브라우저의 HTTPS (안전한) 연결을 사용해 은행에 접속하는 경우를 생각해보자.  
은행은 자신의 공개키를 브라우저에 전송하고, 브라우저는 은행이 보낸 공개키를 사용해 데이터를 암호화한다.  
이때 은행에서 온 공개키가 진짜 은행것임을 브라우저가 확신할 수 있을까 ?

오늘날에는 `PKI(Public Key Infrastructure)` 공개키 인프라스트럭쳐를 사용한다.  
이 인프라에는 우리가 신뢰할 수 있는 제 3자 인증 기관 (`CA(Certificate Authority)`) 이 있어서,  
어떤 키가 어떤 당사자의 것임을 인증해준다.

이 방법이 좋지 않은 이유는, 인증 기관 또한 해킹을 당하거나 직원이 일 처리중에 실수를 했을 때 등  
근본적인 이유는 해결하지 못했기 때문에 신뢰 문제가 생길 수 있는 점이다.  
실제로 일부 인증 기관은 인증서를 요청하는 기관을 제대로 검증하지 않아서 안전하지 않다는 사실이 드러나기도 했다.

<br/>

## 블록 체인

<br/>

블록 체인은 크립토르래피를 응용한 또 다른 분야다.  
블록 체인 개념이 등장하게 된 계기는 앞서 살펴봤던 문제점들을 해결하고 불편함을 해소하는 데에 있다.

블록 체인에서 저장하고자 하는 정보를 담고 있는 한 줄을 `블록` 이라고 부른다.  
새 블록을 만들 때는 이전 블록에 대한 암호학적 해시와 블록 생성 시간을 추가한다.  
이로 인해 블록의 해시와 타임스탬프에 의해 연결된 블록의 체인이 생긴다.

즉 1개의 블록 내용을 업데이트하게 되면,  
해당 블록의 해시가 바뀌기 때문에 이후 블록에 적용된 해시와 일치하지 않게 된다.  
암호학적 해시의 특성으로 인해 해시를 유지하면서도 블록 정보를 변조할 수 있는 가능성은 없다 !  
즉, 현재 블록이 이전 블록에 대한 디지털 서명을 포함한 것 같은 효과가 있다.

블록 체인을 공격하는 유일한 방법은, 블록 체인을 다루는 소프트웨어를 변경하는 방법밖에는 없다.  
블록 체인 데이터가 공개되어 있고, 수많은 시스템에 중복적으로 적용되어있기 떄문에 이 시스템을 공격하려면 많은 사람들의 결탁과 합심이 필요하다.

<br/>

## 패스워드 관리

<br/>

크립토그래피의 응용분야로, `password management` 패스 워드 관리가 있다.  
예전에는 컴퓨터 내에 있는 패스워드 파일에 패스워드가 _평문_ 으로 저장되었다. ㄷㄷ  
이 방법은 파일에 접근만 할 수 있으면 누구나, 모든 사람의 패스워드를 알 수 있기 때문에 좋지 않은 방법이다.

그래서 많은 기업들이 패스워드 백업을 자신이 아닌 제 3자 기관에 보내서 저장하는 방식을 택했다.  
그러나 이또한 누군가가 백업에 있는 다른 데이터에 접근할 수 있기 때문에 보안에 좋지 않다.

이 문제의 간단한 해법은, 패스워드를 암호학적 해시와 같이 암호화된 형태로 저장하는 것이다!  
사용자가 로그인을 시도하면 패스워드를 암호학적 해시로 변환해서 파일에 있는 해시와 비교한다.  
암호학적 해시의 특성때문에 패스워드를 추측하기 매우 어려워진다.

그러나 이러한 방법을 동원해도 패스워드 사용에는 문제가 많다.  
은행, 학교, 쇼핑몰 등등 모든 온라인 상점에 대한 패스워드를 기억해야하기 때문에, 패스워드를 통일해서 사용하는 사람도 있다.  
한 사이트가 공격당하면 다른 모든 사이트에서도 해당 패스워드는 사용할 수 없게 된다.

그나마 효과적인 방법은, 2단계 인증을 하는 것이다.  
2단계 인증은 보통 휴대폰을 사용하기때문에 만약 휴대폰이 없다면 계정에 접근할 수 없는 문제가 생기기도 한다.  
그리고 2단계 인증은 매우 귀찮기 때문에 여러 사람들은 여러 사이트에서 로그인 상태를 유지하는 걸 택한다.

<br/>

보안과 크립토그래피에 대해 알았으므로, 프로그래머로서 이를 어떻게 다룰 수 있는지 생각해보자.  
다음은, 헨리 스펜서가 쓴 `C 프로그래머 십계명` (The Ten Commandments for C Programmers) 이다.

<br/>
<br/>

## 올바른 대상을 보호하라.

<br/>

무언가 안전하게 유지하는 시스템을 설계할 때, 모든 대상을 유지하고싶은 유혹에 빠지기 쉬운데,  
모든 대상을 안전하게 하는 것은 언제나 옳은 생각이 아니다.

<br/>

## 로직은 3번 체크하라.

<br/>

무언가를 하는 프로그램을 작성했는데, 실제로는 원하는대로 동작하지 않는 경우가 꽤 있다.  
로직에 있는 오류를 공격에 활용할 수 있다. 특히, 공격자가 소스 코드를 볼 수 있고 여러분이 찾지 못한 버그를 찾을 수 있다면 공격에 성공할 가능성이 더 커진다.  
다른 사람들과 로직을 항상 체크하는 과정이 필요하다.

<br/>

## 오류를 검사하라.

<br/>

조용히 실패하거나, 메모리의 경계를 넘는 라이브러리를 피하라.  
여러분이 사용하는 언어 도구에서 오류나 경고 보고를 항상 활성화하라.  
메모리 할당의 오류가 나면 치명적인 오류로 간주하라.

<br/>

## 공격 표면을 최소화하라.

<br/>

어떤 소프트웨어에 새로운 기능을 추가할 때마다 새로운 공격 표면이 추가된다는 사실을 아는가.  
이것이 바로 실제 보안 전문가가 백도어를 설치하는 것을 반대하는 이유다.  
백도어를 설치하면 다른 공격 표면을 추가함으로써 소프트웨어가 더 복잡해질 뿐만 아니라,  
권한을 부여받지 못한 당자자가 이런 백도어에 접근할 수 있는 방법을 알아낼 가능성이 크다.  
여러분의 코드를 가능한, 간단하게 유지해서 공격 표면을 줄이는 것이 좋은 보안 방법이다.

<br/>

## 경계 내부에 머물러라.

<br/>

버퍼 오버플로우는 소프트웨어가 데이터의 메모리 경계를 체크하지 않고, 다른 데이터를 덮어쓸 수 있는 경우를 말한다.  
스택 안에서 발생하는 오버플로우가 특히 문제가 된다. 공격자는 함수 호출의 반환 주소를 바꿀 수도 있고,  
그에 따라 프로그램의 나머지 부분이 프로그래머의 의도와 다른 방식으로 실행될 수 있다.

또 다른 문제는 변수 크기 문제이다.  
대부분의 시스템에서는 변수 크기를 정확히 지정하고 싶을 때 사용할 수 있는 정의 파일을 제공한다.  
최악의 경우 파일을 사용해 코드가 잘못된 크기의 변수나 값을 사용하면 컴파일을 막거나,  
최선의 경우 자동으로 올바른 크기를 선택하도록 강제할 수 있다.

<br/>

## 좋은 난수를 생성하기는 힘들다.

<br/>

크립토그래피에는 좋은 난수가 중요하다.  
여러분이 보안이 좋은 난수에 의존해야 한다면, 난수를 생성하는 시스템을 반드시 이해해야 한다.

<br/>

# 보안을 위한 소프트웨어 예방 조치(2)

## 네 코드를 알라

규모가 큰 프로젝트에는 `서드파티 코드(third-party code)`가 들어가는 경우가 있다.

> **서드파티 코드 (third-party code)**
> 프로젝트 팀이 아닌 제 3자가 작성한 코드

서드 파티 코드를 사용할 때는 다음과 같은 `문제`가 생길 수 있다.

- 서브 파티 코드의 소스 코드에 접근할 수 없을 때도 있다. 이 경우에는 코드가 안전하고 잘 작동하는지 알 수가 없다. `백도어`가 설치되어 있는지도 알 수 없다.
- `디지털 헤르페스`: 시스템 통합가에 의해 소프트웨어를 구축할 때 제품에 쓰이지 않는 코드가 제품에 포함될 수 있다.

이런 문제를 `해결`하려면 어떻게 해야할까?

- `오픈 소스 코드`가 더 나을 수 있다.
  - 여러 사람이 살펴보기 때문에 버그를 발견할 가능성이 더 높다.
- 제 3자 패키지에서 실제 사용하는 코드 크기와 전체 패키지 크기 사이의 `비율`을 주시한다.
  - 실제로 사용하지 않을 많은 기능까지 포함하면서 패키지를 사용하기 보다는 필요한 코드를 직접 작성하는 것이 나을 수 있다.
- 디버깅을 위한 코드는 꼭 제거한다.
  <br />

## 극단적인 영리함은 여러분의 적이다

서드파티 코드 사용 시 사람들이 많이 쓰지 않는 기능은 사용하지 않는 것이 좋다.
많이 사용하지 않으므로 벤더가 더 이상 지원하지 않고, 그러면 서드파티 코드가 업그레이드 되지 않아 보안 버그를 수정한 버그 픽스를 설치하지 못할 수 있다.
<br />

## 눈에 보이는 것을 이해하라

민감한 데이터는 우리의 프로그램이 아닌 다른 프로그램이 접근할 수 있는지 생각해보자. 이런 부분을 통해 `위협 모델`을 정의할 수 있다.
코드를 작성하는 일 외에도 `사이드 채널 공격`에 주의를 기울여야 한다.

> **사이드 채널 공격**
> 프로그램 구현의 메타 데이터나 부작용에 기반을 둔 공격 방법

- **타이밍 공격**

  - ex) 암호 검사하는 코드가 있을 때 틀린 암호를 검사하는 것보다 올바를 암호에 가까운 암호를 검사할 때 시간이 더 걸리면 공격자에게 힌트를 주는 것과 같다.

- **반 에크 프리킹**
  - 안테나를 사용해 모니터 방사파를 잡아내 모니터에 표시된 이미지를 원격에서 재현하는 방법
  - ex) 전자 투표 시스템에 사용하면 비밀 투표를 무력화시킬 수 있다.

이런 사이드 채널 공격을 방지하기 위해서 중요한 보안 코드에 대해서 실제 내부에서 일어나는 일을 외부에서 관찰할 수 없도록 해야한다. 즉 사이드 채널을 통해 정보를 노출하는 일이 없게 해야 한다.

<br />

## 과다수집하지 마라

정말 필요한 경우를 제외하고 민감한 정보를 수집하지 않는다.
<br />

## 모아두지 마라

민감한 정보는 가능한 한 빨리 없애는 것이 낫다.
ex) 패스워드는 확인 후 더이상 필요하지 않으므로 오래 저장하지 않는다.
<br />

## 동적 메모리 할당은 여러분의 친구가 아니다

- `malloc()` : 메모리를 할당하는 함수
- `free()` 메모리를 해제하는 함수
- `realloc()`: 할당된 메모리의 크기를 늘리거나 줄이는 함수
  <br />
- **메모리를 해제하기 전에 민감한 정보를 지워야 한다.** <br />
  ![그림 13-7](https://media.discordapp.net/attachments/879215554379018243/1010602652058517524/unknown.png)
  - 그림 13-7을 보면 메모리가 해제되고 나서도 민감한 정보가 계속 존재한다. 따라서 해제하기 전 민감한 정보를 지워야 한다.
- **메모리를 줄이는 경우 그에 따라 반환될 영역에 있는 정보를 지워야 한다.**<br />
  ![그림 13-8](https://media.discordapp.net/attachments/879215554379018243/1010602745759289383/unknown.png)

  - 그림 13-8을 보면 할당된 메모리가 줄어들면, 메모리 영역 밖의 힙으로 비밀정보가 돌아간다. 따라서 반환될 영역에 있는 정보를 지워야 한다.

- **보안이 필수적인 경우 realloc을 사용하지 않는다.**<br />
  ![그림 13-10](https://media.discordapp.net/attachments/879215554379018243/1010602808095019129/unknown.png)
  - 그림 13-10에서 메모리 블록을 키우려고 했는데 다른 블록으로 인해 충분한 공간이 없다. 이 경우 힙에서 충분한 크기의 연속된 메모리 공간을 찾고, 메모리를 할당한다. 이 경우 비밀정보의 복사본이 2본 존재하고, 하나는 할당될 수 있는 힙의 영역에 위치하게 된다.
  - malloc으로 새 메모리를 할당하고, 이전 데이터를 새 블록에 복사한 다음 민감한 데이터를 덮어 씌우고, free로 해제해야 한다.

<br />

## 가비지 컬렉션도 여러분의 친구가 아니다.

중요한 데이터가 불필요하면 지우는 것이 좋다. 그런데 가비지 컬렉션을 사용하면 다음과 같은 문제가 발생한다.

- 중요한 정보인 문자열을 지울 때, 새로운 문자열을 할당한 다음, 민감한 정보가 담긴 문자열은 가비지 컬렉션이 가능한 문자열로 분류한다. 이러면 민감한 정보는 지워지지 않고, 강제로 지울 방법도 없다.

- 플래시 메모리 사용 시 (그 중에서도 SSD), 플래시 메모리 칩에 데이터를 분산해 저장하는 `부하 평탄화` 기능이 들어간다. 즉 어떤 데이터를 기록해도 예전 정보를 덮어쓰지 않는다. 할당된 메모리를 해제해서 그 메모리가 힙의 사용 가능 영역에 남게 되는 것과 비슷하다.

<br />

## 코드 역할을 하는 데이터

- **받는 입력이 코드로 해석되어서는 안된다.**
  - 예를 들면 댓글을 입력할 때 자바스크립트 코드가 입력되면, 이를 확인하는 사용자가 의도치 않게 코드를 실행할 수 있다.
  - 댓글에 html을 사용하도록 허용하면 댓글창이 광고 혹은 다른 웹사이트의 링크로 가득 찰 수 있다.
- **SQL 주입 공격**

  ```sql
  SELECT * FROM students WHERE class = '{$_REQUEST['class']}', && student='$student'
  ```

  위와 같은 SQL 문이 있다. class는 요청받은 class 입력 값과, 로그인 한 학생의 이름과 같은 값을 찾는 SQL문이다.

  그런데 사용자가 class에 `Biology`라는 과목 이름이 아니라 `'Biology' || 1=1 || '; #`을 입력하였다.

  ```sql
  SELECT * FROM students WHERE class = 'Biology' || 1=1 || ''; #, && student='David Lightman'
  ```

  이렇게 되면 #이후는 주석 처리가 되고, 1=1이라는 조건이 항상 성립하므로 David의 정보가 아닌 모든 학생들의 정보를 얻을 수 있다.

  이 뿐만 아니라 세미콜론 뒤에 데이터베이스를 갱신하는 SQL 명령을 더 입력할 수 있다.
