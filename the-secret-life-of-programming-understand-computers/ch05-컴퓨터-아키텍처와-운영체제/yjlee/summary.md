# 기본적인 구조 요소들
가장 흔한 컴퓨터 구조는 폰 노이만(von Neumann) 구조와 하버드(Harvard) 구조이다.
두 구조의 유일한 차이는 메모리 배열뿐이다.
![](https://mblogthumb-phinf.pstatic.net/MjAyMDA1MjhfMTk5/MDAxNTkwNjMyNjI3MzIx.5T3C2x7AiHSIVoiUYq6eqmeI8LWdbP0ZaEARSIbSZ4kg.b9GN7dtKoYYF23qTQJG4Vw_z2kaR_bR4xrNjteeSZ7og.PNG.with_msip/%EC%82%AC%EC%A7%845.PNG?type=w800) 
폰 노이만 구조
- 폰 노이만 구조가 나오면서, CPU, 메모리, 프로그램 구조를 갖는 범용 컴퓨터 구조가 확립되었다. (이전에는 스위치를 설치, 전선을 연결하고, 데이터를 전송해 신호를 처리하는 식으로 프로그래밍 함)
- 명령어와 데이터를 동시에 가져올 수 없기 때문에 약간 느리다. 이를 해결하기 위해 하버드 구조가 나왔다.
- 메모리 값을 읽고 쓰는 구조이기 때문에 기억 장치에 병목 현상이 생길 수 밖에 없다. (이를 해결하기 위해 메모리 계층 구조, NUMA, DMA 등이 있다.)
- 컴퓨터에 다른 작업을 시킬 때 굳이 하드웨어를 재배치 할 필요 없이, 소프트웨어만 교체하면 되므로 범용성이 크게 향상된다.

하버드 구조
- 명령어와 데이터를 동시에 가져올 수 있으므로 더 빠르다.
- 두 번째 메모리를 처리하는 버스가 따로 필요하다.
- 이러한 처리 속도를 높이려면, 많은 전기회로가 필요하다.

위의 두 구조는 CPU가 하나뿐이었는데 프로세서 코어(CPU)가 여러 개 들어가는 멀티 코어 프로세서가 일반적으로 사용된다.

### 마이크로프로세서와 마이크로 컴퓨터
물리적인 패키징에 따라 구조를 구분할 수도 있다.

마이크로 프로세서
- 메모리와 I/O가 프로세서 코어와 같은 패키지에 들어있지 않은 프로세서
- 보통 큰 시스템에 들어가는 부품으로 쓰인다.

마이크로 컴퓨터
- 모든 요소를 한 칩 안에 패키징한 것
- 식기 세척기 등에서 찾을 수 있는 작은 컴퓨터이다.

단일 칩 시스템(SoC, System on a Chip)
- 더 복잡한 마이크로컴퓨터. 상대적으로 간단한 on-chip(칩 내부에 존재하는) I/O를 제공하는 대신, Wifi 회로 등 더 복잡한 장치가 들어있다.
- 핸드폰 등의 장치에서 볼 수 있다.


# 프로시저, 서브루틴, 함수
- 코드를 재사용하는 주요 수단.
- 코드가 차지하는 메모리를 줄이고, 버그가 있는 경우 여러 부분을 고치지 않고 한 군대만 고치면 된다는 장점이 있다.


함수를 여러 번 **호출**(call, invoke)하여 코드를 재사용할 수 있다.
```
| 주소 | 명령어 | 피연산자  | 설명                                                           |
| ---- | ------ | --------- | -------------------------------------------------------------- |
| 100  | pca    |           | 프로그램 카운터 => 누산기                                      |
| 101  | add    | 5(즉시)   | 함수에서 돌아올 주소(100 + 5 = 105)                            |
| 102  | store  | 200(직접) | 돌아올 주소를 메모리(200번지)에 저장                           |
| 103  | load   | 3(즉시)   | 세제곱할 값(함수의 파라미터값)을 누산기에 넣기                 |
| 104  | bra    | 300(직접) | cube함수를 호출(분기)                                          |
| 105  |        |           | 함수에서 돌아온 뒤 실행될 부분                                 |
| ...  |        |           |                                                                |
| 200  |        |           | 함수에서 돌아올 주소를 저장하기 위해 미리 확보해둔 메모리 위치 |
| ...  |        |           |                                                                |
| 300  |        |           | cube 함수의 시작 부분                                          |
| ...  |        |           | cube 함수의 나머지 명령어들                                    |
| 310  | bra    | 200(간접) | 저장했던 주소로 돌아감(간접 주소 지정을 사용해 분기)           |

```
101 -> 102 -> 103 -> 104 -> 300 ... -> 310 -> 200 -> 105

함수에서 `돌아올 주소`를 계산 -> 돌아올 주소를 메모리 `200번지`에 저장 -> 함수 `파라미터값`을 `누산기`에 넣기 -> 함수 `호출` -> 실제 코드를 실행 -> 돌아올 주소를 저장했던 주소(200번지)로 돌아감 -> 저장된 값을 사용해 `간접 분기`(310번지) -> 함수에서 돌아온 뒤 실행 부분

# 스택

### 재귀(Recursive)

자기 자신을 호출하는 함수이다. 재귀 함수가 호출될 때마다 메서드의 복사본이 메모리에 저장된다. 그리고 메서드가 반환하는 메서드의 복사본은 메모리에서 삭제된다.

### 쿼드 트리(Quad tree)

트리 자료구조 중 하나로 부모 노드 아래 자식 노드를 4개씩 갖고 있는 트리 구조로 2차원 데이터를 공간적으로 관리하기 위한 자료구조이다. 대량의 좌표 데이터를 메모리 안에 압축해 저장하기 위해 사용하는 기법 중 하나이며, 이미지 용량, 충돌, 컬링 등 다양한 곳에서 최적화 기법으로 사용된다.

<div align="center">

![](https://blog.kakaocdn.net/dn/cVR5RB/btqW8HbJJN3/5xF4MeXmTzfWRq9cnR6DTK/img.png)

</div>

재귀를 통해 계속해서 분할하는 작업을 수행하고, 각 노드 내부의 모든 색이 같아 분할 작업이 필요없거나 간격이 1 이하일 때까지 반복한다. 이 과정이 모두 끝난 후 리프 노드들을 고려하면 원래 초기 지형보다 메모리에 저장되는 크기가 줄어든다.(**압축**)

### 깊이 우선 순회(Depth-first traversal)

트리 구조를 순회할 때, 수직으로 먼저 접근하되 더 이상 내려갈 수 없는 노드일 경우에 옆으로 이동하는 방식이다.

### 너비 우선 순회(Breadth-first traversal)

깊이 우선 순회와 반대로 좌우 수평으로 먼저 이동해 방문한 다음 아래쪽으로 내려가는 방식이다.

### 스택(Stack)

`LIFO(last in first out_후입선출)` 구조로 재귀 함수에서 깊이 우선 순회를 구현할 때 주로 쓰인다.
스택에 더 이상 공간이 없으면 `스택 오버플로(Stack overflow)`라고 하고, 반대로 비어 있는 스택에서 데이터를 가져오려는 경우를 스택 `언더플로(Stack underflow)`라고 한다.

### 스택 프레임(Stack frame)

단순히 반환 주소 저장 외에 로직에서 사용하는 매개변수와 지역 변수도 저장된다. 이처럼 함수가 호출될 때마다 스택에 저장되는 데이터의 모음이 스택 프레임이다. 스택 프레임은 함수의 호출이 완료되면 소멸한다.

### 여러 가지 수식 표기법

- infix : 연산자를 두 피연산자 사이에 표기하는 방법으로 가장 일반적으로 사용되는 표현 방법 `ex) A + B`
- prefix : 연산자를 먼저 표시하고 연산에 필요한 피연산자를 나중에 표기하는 방법 `ex) + A B`
- postf

# 인터럽트

실행 중인 프로그램을 잠깐 중단(`interrupt`)시키고 외부의 요소에 대응할 수 있게 한다.

### 인터럽트 시스템 동작 원리

1. 인터럽트 요청 신호 발생
2. 프로그램 실행 중단
3. 현재 프로그램 상태 보존
4. 인터럽트 처리 루틴 실행 - 인터럽트 핸들러
5. 인터럽트 취급(서비스) 루틴 실행 (실질적인 인터럽트 처리)  - 인터럽트 핸들러
6. 상태 복구
7. 중단된 프로그램 실행

인터럽트 시스템은 서비스 후 돌아올 프로그램의 위치는 **Stack**에 저장된다. 인터럽트 핸들러의 주소에 대한 메모리 주소는 인터럽트 백터(포인터)를 통해 찾는다.


# 상대 주소 지정

여러 프로그램을 동시에 실행하기 위해서는 각 프로그램을 서로 전환시켜 줄 수 있는 `관리자 프로그램`이 필요한데, 이런 프로그램을 `운영 체제` 또는 `커널(kernel : 중심)` 이라고 부른다.

### 주소지정방식의 종류

`암시적` 주소지정방식 (Implied Mode)
- 0주소 (`스택`)

`즉시적` 주소지정방식 (Immediate Mode)
- 메모리에 `실제 데이터`가 들어있음      
- 별도의 기억 장소에 엑세스하지 않고 CPU에 바로 접근하기 때문에 실행 속도가 빠름   
- 명령어의 길이에 영향을 받으므로 표현할 수 있는 실제 데이터 값의 길이가 제한적임

`직접` 주소지정방식 (Direct Mode)
- 메모리에 실제 데이터를 가리키는 `주소`가 들어있음     
- 주소 부분에 실제 사용할 데이터의 유효 주소를 적기때문에 주소 길이의 제약을 받음

`간접` 주소지정방식 (Indirect Mode)
- 메모리에 실제 데이터를 가리키는 `주소의 주소`가 들어있음    
: 명령어의 길이가 짧고 제한적이어도 긴 주소에 접근 가능한 방식

계산에 의한 주소지정방식   
- `Operand`부와 `CPU`의 특정 레지스터 값이 더해져서 유효 주소를 계산하는 방식
- 상대 주소 (Relative Mode) : 유효 주소 = 명령어의 주소 부분 + PC
- 베이스 레지스터 (Base Register Mode) : 유효 주소 = 명령어의 주소 부분 + 베이스 레지스터 
- 인덱스 레지스터 (Index Register Mode) : 유효 주소 = 명령어의 주소 부분 + 인덱스 레지스터

# 메모리 관리 장치
`가상 주소`와 `물리 주소`를 구분하여 `MMU`를 통해 실제(물리) 메모리 주소로 변환해준다.

<img width="500" alt="image" src="https://user-images.githubusercontent.com/91880235/172491590-3f9a2270-9eb9-414c-9458-2fca42817018.png">

### MMU 처리방식

CPU가 논리 주소 346 값을 요청하면 MMU는 `Base Register` 14000을 더해서 물리주소인 14346을 통해 메모리에서 실제 주소를 받는다.

<img width="499" alt="image" src="https://user-images.githubusercontent.com/91880235/172615006-c0cae562-471a-4d96-b3b0-613901df4a4c.png">

### 연속 메모리 할당(Contiguous Allocation)

커널이 저장되는 영역을 제외한 남은 공간에 사용자의 프로세스를 연속적으로 저장한다.
- `베이스 레지스터` : 프로세스의 시작 주소가 저장
- `리미트 레지스터` : 프로세스의 길이가 저장
- `리미트 레지스터` : 길이를 초과하면 주소 에러를 내보냄

프로세스가 종료되면 메모리 공간에 종료된 프로세스 길이만큼 빈 공간이 발생한다.
이 빈공간 처리에 대한 부분은 아래와 같이 3가지 방법으로 처리할 수 있다.
- `first-fit`: 첫번째 빈 공간에 할당한다.
- `best-fit`: 가장 적합한 빈 공간에 할당한다.
- `worst-fit`: 가장 큰 빈 공간에 할당한다.

### 외부 단편화(external Fragmentation)
- 빈 공간에 적합하거나 작은 프로세스를 할당하다보면 작은 공간이 무수하게 많아지는 경우가 발생한다.
- 다음 들어올 프로세스가 들어올 수 있는 메모리 공간에 있음에도 불구하고, 연속적이지 않고, 너무 많은 빈 공간들이 조각으로 남아있는 경우를 `외부 단편화`라 한다. 
- 보통 `best-fit`을 사용할 경우 발생하는 문제이다.

<img width="400" alt="image" src="https://user-images.githubusercontent.com/91880235/172618573-c04a3ac2-73e8-419f-a97e-a306a7490fc3.png">

### 페이징 기법(Paging)

- 외부 단편화를 해결하기 위해 페이징 기법이 구현된다.
- 페이징 기법은 프로세스를 일정 크기인 `페이지`로 잘라서 비연속적으로 메모리에 적재하는 방식
- 페이지 번호(page number) `-p`와 페이지 참조 번호 (page offset)`-d`이 순서쌍 (p, d)으로 갖고 있다.

- `frame`과 `page`는 메모리를 일정한 크기의 공간으로 나누어 관리하는 단위로, 프레임과 페이지의 크기는 같다.
- `frame` : 물리 메모리를 일정한 크기로 나눈 블록
- `page` : 가상 메모리를 일정한 크기로 나눈 블록
- `페이징 테이블` : 프로세스의 페이지 정보를 저장하고 있으며, 하나의 프로세스는 하나의 페이지 테이블을 가진다.

### 내부 단편화(Internal Fragment)

- 내부 단편화는 프로세스 크기가 페이지 크기의 배수가 아닐 경우 마지막 페이지는 한 프레임을 다 채울 수 없다.
- 이로 인해 발생하는 공간은 결국 메모리 낭비로 이어진다. 
- 내부 단편화는 해결할 방법이 없지만 외부단편화에 비해 낭비되는 공간이 매우 적다.

<img width="500" alt="image" src="https://user-images.githubusercontent.com/91880235/172619377-c99b1420-81e4-44b9-9a71-fd3531eee477.png">

# 가상 메모리
OS는 `MMU`를 사용해 메모리가 실제 메모리보다 많아 보이게 하는 기술인 가상 메모리를 제공한다. 메모리의 일부분을 디스크에 저장하여 사용하는 `디스크 스왑`이라고 불리는 것과는 별개의 기술이다.
- 사용자가 기억장소를 일일히 할당하는 불편을 없애준다.
- 프로세스의 크기가 실제 메모리의 용량을 초과해도 실행될 수가 있다.
- 물리적 메모리의 용량이 충분히 크다하더라도 다중 프로그래밍이 가능하다.

### 요구불 페이징(Demand Paging)

- 프로세스의 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재함. 이 때 `valid/Invalid bit`가 사용된다.

- `Invalid/Valid Bit`: 사용되지 않는 주소 영역인 경우, 페이지가 물리적 메모리에 없는 경우 (valid는 반대)
  처음에는 모든 page가 invalid로 초기화되고, 사용되면 valid로 되는데, address translation시에 invalid bit이라면 `page fault`가 발생한다.

- `Page fault`: 어떤 페이지가 물리 메모리에 없을 때 발생하는 인터럽트로, `Page fault`가 발생하면 운영체제가 해당 페이지를 물리 메모리에 올려준다.

- `Swap Out`: 요청받은 메모리가 사용 가능한 메모리의 크기보다 크다면 현재 필요 없는 페이지를 느리지만 용량이 큰 디스크로 옮김

- `Swap In`: `Swap Out`한 페이지로 접근이 필요하면 메모리 공간을 확보하고 해당 페이지를 다시 메모리로 불러들이는 것
이런 식으로 페이지 처리하는 것을 `요구불 페이징(Demand Paging)` 이라고 한다.

### 페이지 교체 정책(Page Replacement policy) 알고리즘
어떤 페이지를 물리 메모리에서, 저장 매체로 내릴 것인가에 대한 것이 `페이지 교체 정책`이다.

- `FIFO 알고리즘`: 가장 먼저 들어온 페이지를 내린다.

- `OPT(OPTimal) 알고리즘`: 앞으로 가장 오랫동안 사용하지 않을 페이지를 내린다는 최적 페이지 알고리즘.그러나 미래에 어떤 페이지를 얼마나 사용할 것인지는 알 수 없으므로 일반 OS에서는 구현이 불가하다.

- `LRU(Least Recently Used) 알고리즘`: 가장 오래전에 사용된 페이지를 내린다.

- `LFU(Least Frequently Used) 알고리즘`: 가장 적게 사용된 페이지를 내린다.

- `NUR(Not Used Recently) 알고리즘`: LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 내리자는 알고리즘인데, 각 페이지마다 참조 여부를 나타내는 비트(R), 수정 여부를 나타내는 비트(M)을 두어서 (0, 0), (0, 1), (1, 0), (1, 1) 순으로 교체한다.

# 시스템 공간과 사용자 공간

하드웨어인 MMU의 설정을 마음대로 바꿀 수 있거나, 운영체제가 설정하는 초당 인터럽트 발생 횟수 등을 유저가 조작한다면 프로그램이 비정상적으로 작동할 확률이 크다. 
이러한 문제를 해결할 수 있도록 CPU에는 컴퓨터가 `시스템 모드`에 있는 지 `사용자 모드`에 있는지 결정하는 비트가 어떤 레지스터 안에 들어있다.

`트랩`이나 `시스템 콜`이라고 부르는 특별한 명령어를 통해 `시스템 모드 프로그램(운영체제)`으로 요청을 보낼 수 있다.

- `트랩`: 레지스터와 스택 포인터가 저장되고 컨텍스트 스위칭이 일어나고, 실행이 재개될 수 있다는 면에서 인터럽트와 굉장히 흡사하다. 그래서 이를 CPU 내부 인터럽트라고도 한다.
- `시스템 콜`: 커널 기능을 커널에 요청하는 방식. 트랩을 통해서 실제로 커널에 정보가 전달된다.

### 커널이 하는 일
`커널`은 사용자가 `시스템 콜`을 통해 컴퓨터 자원을 사용할 수 있게 해주는 `자원관리자`라고 볼 수 있다.

- `태스크 관리자` : CPU를 task라는 추상적인 자원으로써 제공
- `메모리 관리자` : 메모리를 segment나 page로 제공
- `파일시스템` : 디스크를 파일로 제공
- `네트워크 관리자` : 네트워크 장치를 소켓으로 제공
- `디바이스 드라이버 관리자` : 각종 장치를 디바이스 드라이버를 통해 일관되게 접근하도록 함 


# 메모리 계층과 성능

## 메모리 계층 구조
- 메모리는 가격과 성능이 비례하고 성능과 용량은 반비례한다.
- 각각의 특징이 있는 서로 다른 여러 종류의 저장 장치를 함께 사용하여 `최적의 효율`을 낼 수 있게 `가격 대비 좋은 성능`의 컴퓨터를 구현하기 위함이다.

<img width="601" alt="image" src="https://user-images.githubusercontent.com/91880235/173183504-520672c9-aedc-4748-a2f7-b53ea98d35cd.png">

## 메모리 종류
### 레지스터
- 컴퓨터에서 제일 빠른 메모리로, CPU 계산 과정에서 작동한다. 
- 컴퓨터에서 4대 주요 기능(기억, 해석, 연산, 제어)을 관할하는 장치
- CPU는 자체적으로 데이터를 저장할 방법이 없으므로 메모리로 직접 데이터를 전송할 수 없음
  → 연산을 위해서 반드시 레지스터를 거쳐야 하며, 이를 위해 레지스터는 특정 주소를 가리키거나 값을 읽어올 수 있음
- CPU 내부 레지스터 종류로는 `프로그램 카운터`, `누산기`, `명령어 레지스터`, `상태 레지스터` 등이 있다.

### 캐시 메모리
- 레지스터 다음으로 빠른 메모리로, CPU와의 거리에 따라 `L1 ~ L3 캐시` 등 여러 단계로 나뉜다.
- 데이터나 값을 미리 복사해 놓는 임시 장소로, 보통 <u>SRAM</u>으로 구성되며 숫자가 작을수록 CPU에 가까운 상위레벨 캐시로 용량이 작고 빠르다.
- 속도가 빠른 장치와 느린 장치 사이에서 속도차에 따른 <u>병목 현상을 완화</u>하기 위한 범용 메모리

캐시메모리의 지역성
- 시간적 지역성 : 특정 데이터가 한 번 접근되었을 경우, 가까운 미래에 또 한 번 데이터에 접근할 가능성이 높음
- 공간적 지역성 L 액세스 된 기억장소와 인접한 기억장소가 액세스 될 가능성이 높음

### 메인 메모리
- CPU, 메인보드와 분리되어있는 메모리 중 `최상위 메모리`로 `RAM`과 `ROM`이 해당 
- 컴퓨터가 빠른 액세스를 하기 위해 데이터를 단기간 저장하는 구성 요소
- 사용자가 요청하는 프로그램이나 문서를 스토리지에서 메모리로 로드하여 각각의 정보에 액세스
- 스토리지(SSD, HDD)와 비교하면 차원이 다르게 빠름 

### 스토리지 (SSD, HDD)
- `보조 기억장치`로 불린다.
- 주로 ATA(Advanced Technology Attachment, 고급기술결합)라는 중간 인터페이스 규격과 연결되어 통신한다.
- NVMe SSD는 CPU와 직접 통신한다.

### 이동식 저장장치
- USB 메모리, ODD 등을 의미
- 기업용으로는 자기 테이프 등..

# 코프로세서
`코프로세서`는 보조프로세서 또는 보조 처리기 라고도 부른다.  
부동소수점 산술, 그래픽, 신호 처리, 문자열 연산, 암호화, 주변장치 입출력 등의 프로세스 코어에 비해 단순한 기능을 담당한다.  
프로세스 코어에 집중된 기능들 중 단순 처리하며 부담을 덜어주는 역할을 한다.  

# 메모리에서의 데이터 배치

### 정적(static) 데이터  
- 프로그램 작성 시 얼마나 많은 메모리가 필요한지 알고 있는 데이터  
- 서로 메모리가 충돌하지 않도록 배치 할 수 있다.  

### 동적(dynamic) 데이터  
- 프로그램을 실행하기 전에는 크기를 알 수 없는 데이터  
- 동적 데이터는 정적 데이터가 차지하는 영역 바로 위에 쌓이고 이를 `힙(heap)`이라고 부른다.  

![메모리](https://user-images.githubusercontent.com/91672778/173217747-972d456e-598a-46dd-a21e-165485db09b8.png)

### 힙(heap)
- 동적으로 할당하는 메모리 공간으로 힙 영역이 커지다가 스택 영역을 침범하면 heap overflow라고 한다.  

# 프로그램 실행
프로그램이 실행될 때 먼저 `런타임 라이브러리(runtime library)`가 실행되고 프로그램의 `진입점(entry point)`의 명령어가 실행된다.  


### 라이브러리(library)
- 소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임이다.  
- 구성 데이터, 문서, 도움말 자료, 메시지 틀, 미리 작성된 코드, 서브루틴(함수), 클래스, 값, 자료형 사양을 포함할 수 있다.  

### 링커(linker)
- 여러 파일들을 병합해 하나의 프로그램으로서 실행시키는 프로그램  
  
정적 링크(static link)  
- 실행 파일과 정적 라이브러리 파일을 모두 복사해 하나의 실행 파일로 만들어 메모리에 올린다.  
- 자주 사용되는 라이브러리가 있다면 계속해서 실행파일에 추가되기 때문에 메모리를 낭비하게 된다.  

동적 링크(dynamic link)
- `공유 라이브러리(shared library)`주소만 가지고 있다가  
- 메모리에서 실행파일이 실행되면서 라이브러리가 필요하면 메모리에 올린다.    
- 여러 곳에서 해당 라이브러리를 참조해 사용할 수 있다.  


### 런타임 라이브러리(runtime library)
여러 파일들이 하나로 합쳐져서 실행파일이 생성될 때 추가된다.  
스택과 힙의 영역을 설정하고 정적 데이터가 위치한 데이터의 초기값 등을 설정하는 역할을 한다.  

### 진입점(entry point)
프로그램의 첫 번째 명령어가 위치한 주소

--- 

출처 : [alsrlqor1007/TheSecretLifeOfPrograms_GroupStudy/[05장] 컴퓨터 아키텍처와 운영체제](https://github.com/alsrlqor1007/TheSecretLifeOfPrograms_GroupStudy/tree/main/%5B05%EC%9E%A5%5D%20%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%99%80%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)
