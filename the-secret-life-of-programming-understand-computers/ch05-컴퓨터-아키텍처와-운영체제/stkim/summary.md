5장에서는 컴퓨터 아키텍처와 운영체제에 대해 살펴본다.

| 컴퓨터 아키텍처(Computer Architecture): 컴퓨터의 여러 구성 요소를 배치하는 방법

---

# 기본적인 구조 요소들

가장 흔한 컴퓨터 구조는 **폰 노이만(von Neumann) 구조**와 **하버드(Harvard) 구조**이다.

![폰 노이만 구조와 하버드 구조](https://github.com/RyanKor/book-review/assets/40455392/b6b59256-2868-40d5-a2ff-7c61eac1f3ea)

두 구조의 유일한 차이는 `메모리 배열`뿐이다.

**폰 노이만 구조**

- 폰 노이만 구조가 나오면서, CPU, 메모리, 프로그램 구조를 갖는 `범용 컴퓨터 구조`가 확립되었다. (이전에는 스위치를 설치, 전선을 연결하고, 데이터를 전송해 신호를 처리하는 식으로 프로그래밍 함)
- `명령어`와 `데이터`를 동시에 가져올 수 없기 때문에 약간 느리다. 이를 해결하기 위해 `하버드 구조`가 나왔다.
- 메모리 값을 읽고 쓰는 구조이기 때문에 기억 장치에 병목 현상이 생길 수 밖에 없다. (이를 해결하기 위해 `메모리 계층 구조`, `NUMA`, `DMA` 등이 있다.)
- 컴퓨터에 다른 작업을 시킬 때 굳이 하드웨어를 재배치 할 필요 없이, 소프트웨어만 교체하면 되므로 `범용성`이 크게 향상된다.

**하버드 구조**

- 명령어와 데이터를 동시에 가져올 수 있으므로 더 빠르다.
- 두 번째 메모리를 처리하는 버스가 따로 필요하다.
- 이러한 처리 속도를 높이려면, 많은 전기회로가 필요하다.

현대에는 CPU의 외부적으로는 폰 노이만 구조, 내부적으로는 하버드 구조를 적용하여 속도를 향상시킨 것이 많다. 이렇게 폰 노이만 구조의 병목 현상을 해결하였다.

  <br />

### 프로세서 코어

위의 두 구조는 CPU가 하나뿐이다.
**1980년대**=> `멀티 프로세서 시스템` - 단일 CPU보다 더 좋은 성능을 얻는 방법
그러나 여러 CPU를 사용하도록 프로그램을 `병렬화`하는 일이 쉽지는 않았다.

그러나 반도체 회로 크기가 줄어들고, 비용도 낮아지면서 CPU를 더 빠르게 만들 수 있었고, 더 나은 성능을 가지게 되었다.

**2000년대** => `전력 장벽`
기계가 더 빨라지면서, 전력을 더 많이 소모하고, 단위 면적당 열 발생이 더 많아지면서 `전력 장벽`에 부딪혔다.

이후 사람들은 작아진 회로 크기를 활용한 새로운 해결책을 찾아냈다. CPU를 `프로세서 코어`라고 부르고, 이 코어가 여러 들어가는 `멀티 코어 프로세서`가 일반적으로 사용된다.

<br />

### 마이크로프로세서와 마이크로 컴퓨터

물리적인 패키징에 따라 구조를 구분할 수도 있다.

**마이크로 프로세서**

- 메모리와 I/O가 프로세서 코어와 같은 패키지에 들어있지 않은 프로세서
- 보통 큰 시스템에 들어가는 부품으로 쓰인다.

**마이크로 컴퓨터**

- 모든 요소를 한 칩 안에 패키징한 것 (마이크로컨트롤러라고도 한다)
- 식기 세척기 등에서 찾을 수 있는 `작은 컴퓨터`이다.

칩 안에서 메모리가 차지하는 영역이 크기 때문에 `마이크로프로세서`보다 `마이크로컴퓨터`가 덜 강력하다.

**단일 칩 시스템(SoC, System on a Chip)**

- 더 복잡한 마이크로컴퓨터.
  상대적으로 간단한 on-chip(칩 내부에 존재하는) I/O를 제공하는 대신, Wifi 회로 등 더 복잡한 장치가 들어있다.
- 핸드폰 등의 장치에서 볼 수 있다.

# 프로시저, 서브루틴, 함수

### 코드의 재사용

**함수(function, 혹은 프로시저(procedure), 혹은 서브루틴(subroutine))**

- 코드를 재사용하는 주요 수단.
- 코드가 차지하는 메모리를 줄이고, 버그가 있는 경우 여러 부분을 고치지 않고 한 군대만 고치면 된다는 장점이 있다.

ex) 자바스크립트 함수

```javascript
function cube(x) {
  return x * x * x;
}
```

이렇게 함수를 작성해 아래와 같이 프로그램을 작성할 수 있다.

```javascript
y = cube(3);
```

여기서 우리는 cube를 여러 번 작성하지 않아도 이 함수를 여러 번 **호출**(call, invoke)할 수 있다.

이러한 코드는 어떻게 작동하는걸까?
<br />

**함수 호출하기**
명령어 집합을 통해 함수를 호출하는 방법을 알아보자

| 주소 | 명령어 | 피연산자  | 설명                                                           |
| ---- | ------ | --------- | -------------------------------------------------------------- |
| 100  | pca    |           | 프로그램 카운터 => 누산기                                      |
| 101  | add    | 5(즉시)   | 함수에서 돌아올 주소(100 + 5 = 105)                            |
| 102  | store  | 200(직접) | 돌아올 주소를 메모리(200번지)에 저장                           |
| 103  | load   | 3(즉시)   | 세제곱할 값(함수의 파라미터값)을 누산기에 넣기                 |
| 104  | bra    | 300(직접) | cube함수를 호출(분기)                                          |
| 105  |        |           | 함수에서 돌아온 뒤 실행될 부분                                 |
| ...  |        |           |                                                                |
| 200  |        |           | 함수에서 돌아올 주소를 저장하기 위해 미리 확보해둔 메모리 위치 |
| ...  |        |           |                                                                |
| 300  |        |           | cube 함수의 시작 부분                                          |
| ...  |        |           | cube 함수의 나머지 명령어들                                    |
| 310  | bra    | 200(간접) | 저장했던 주소로 돌아감(간접 주소 지정을 사용해 분기)           |

![함수 호출 흐름](https://cdn.discordapp.com/attachments/879215554379018243/985184912686587935/IMG_9622.png)

1. 101: 함수에서 `돌아올 주소`를 계산
2. 102: 돌아올 주소를 메모리 `200번지`에 저장
3. 103: 함수 `파라미터값`을 `누산기`에 넣기
4. 104: cube 함수 `호출`
5. 300~: cube 함수의 시작 부분 ~~ 나머지 모든 코드를 실행
6. 310: 돌아올 주소를 저장했던 주소(200번지)로 돌아감
7. 200: 저장된 값을 사용해 `간접 분기`(=> 105번지)
8. 105: 함수에서 돌아온 뒤 실행 부분
   <br />

이 과정에 상당히 많은 작업이 필요하고, 기계는 이런 과정을 돕는 명령어를 제공한다.
ex) **ARM(암) 프로세서**의 `링크 레지스터를 사용한 분기(BL, Branch with Link)` 명령어
함수로 호출하는 명령어와 현재 명령어의 다음 위치를 저장하는 명령어를 하나로 합친 것

## 스택

> 재귀(Recursive)

자기 자신을 호출하는 함수이다. 자신의 복사본을 호출해 더 작은 문제를 풀어 전체 문제를 해결하는 것을 재귀적 방법이라고 한다.

<div align="center">

![](https://miro.medium.com/max/1400/1*gS9PPyWUDA0XJIxjab4ncg.png)

</div>

위 사진은 재귀와 메모리를 시각화한 것이다. 재귀 함수가 호출될 때마다 메서드의 복사본이 메모리에 저장된다. 그리고 메서드가 반환하는 메서드의 복사본은 메모리에서 삭제된다.

<br/>

> 쿼드 트리(Quad tree)

트리 자료구조 중 하나로 부모 노드 아래 자식 노드를 4개씩 갖고 있는 트리 구조로 2차원 데이터를 공간적으로 관리하기 위한 자료구조이다. 대량의 좌표 데이터를 메모리 안에 압축해 저장하기 위해 사용하는 기법 중 하나이며, 이미지 용량, 충돌, 컬링 등 다양한 곳에서 최적화 기법으로 사용된다.

<div align="center">

![](https://blog.kakaocdn.net/dn/cVR5RB/btqW8HbJJN3/5xF4MeXmTzfWRq9cnR6DTK/img.png)

</div>

초기에 하나의 넓은 지형을 4등분하고 이들을 자식 노드로 간주한다. 그리고 각각의 자식 노드들을 다시 부모 노드로 간주하고 동일하게 4등분한다. 여기까지 총 16개의 노드가 존재한다. 재귀를 통해 계속해서 분할하는 작업을 수행하고, 각 노드 내부의 모든 색이 같아 분할 작업이 필요없거나 간격이 1 이하일 때까지 반복한다. 이 과정이 모두 끝난 후 리프 노드들을 고려하면 원래 초기 지형보다 메모리에 저장되는 크기가 줄어든다. 이것을 압축이라고 한다.

<div align="center">

![](http://algospot.com/media/judge-attachments/0cafdb9ffa8ace4fb8315949d25d2fb3/quadtree.png)

</div>

<br/>

> 깊이 우선 순회(Depth-first traversal)

트리 구조를 순회할 때, 수직으로 먼저 접근하되 더 이상 내려갈 수 없는 노드일 경우에 옆으로 이동하는 방식이다.

<br/>

> 너비 우선 순회(Breadth-first traversal)

깊이 우선 순회와 반대로 좌우 수평으로 먼저 이동해 방문한 다음 아래쪽으로 내려가는 방식이다.

<br/>

> 스택(Stack)

위에서 다룬 재귀 함수와 트리 순회가 작동하기 위해서는 `스택`이 필요하며 대부분의 컴퓨터 하드웨어에서 지원한다고 한다. 재귀 함수에서는 반환 주소를 저장해야 하며, 트리에서도 한 depth 내려갈 때마다 돌아올 위치를 기억해야 한다. 함수를 호출할 때는 반환 주소를 스택에 넣고, 다시 원래 함수 로직으로 돌아올 때는 스택 가장 마지막 요소에 저장된 주소를 통해 돌아온다. 이런 구조를 `LIFO(last in first out_후입선출)`라고 한다.  
스택에 더 이상 공간이 없으면 `스택 오버플로(Stack overflow)`라고 하고, 반대로 비어 있는 스택에서 데이터를 가져오려는 경우를 스택 `언더플로(Stack underflow)`라고 한다.

<br/>

> 스택 프레임(Stack frame)

단순히 반환 주소만을 저장하기 위해 스택을 사용하지는 않는다. 로직에서 사용하는 매개변수와 지역 변수도 저장된다. 따로 저장되기 때문에 함수가 호출될 때마다 서로 독립적으로 작동한다. 이처럼 함수가 호출될 때마다 스택에 저장되는 데이터의 모음이 스택 프레임이다. 스택 프레임은 함수의 호출이 완료되면 소멸한다.

<div align="center">

![](http://www.tcpschool.com/lectures/img_c_stackframe_01.png)
![](http://www.tcpschool.com/lectures/img_c_stackframe_02.png)

</div>

```
Step 1. 프로그램이 실행되면 가장 먼저 main() 함수가 호출되어 main() 함수의 스택 프레임이 스택에 저장

Step 2. func1() 함수를 호출하면 해당 함수의 매개변수, 반환 주소값, 지역 변수 등의 스택 프레임을 스택에 저장

Step 3. func2() 함수를 호출하면 해당 함수의 스택 프레임을 추가로 저장

Step 4. func2() 함수의 모든 작업이 완료되어 반환되면 func2() 함수의 스택 프레임만 스택에서 제거

Step 5. func1() 함수의 호출이 종료되면 func1() 함수의 스택 프레임 제거

Step 6. main() 함수의 모든 작업이 완료되면 main() 함수의 스택 프레임이 제거되면서 프로그램 종료
```

<br></br>

### 여러 가지 수식 표기법

> 중위 표기법(Infix)

연산자를 두 피연산자 사이에 표기하는 방법으로 가장 일반적으로 사용되는 표현 방법 `ex) A + B`

> 전위 표기법(Prefix, 폴란드 표기법)

연산자를 먼저 표시하고 연산에 필요한 피연산자를 나중에 표기하는 방법 `ex) + A B`

> 후위 표기법(Postfix, 역 폴란드 표기법)

피연산자를 먼저 표시하고 연산자를 나중에 표시하는 방법 `ex) A B +`

<br></br>

### 참고

- [[데이터 구조] 재귀(recursive) 란?](https://medium.com/@sunnkis/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EC%9E%AC%EA%B7%80-8d96633be4cd)
- [[알고리즘] 쿼드트리(Quad Tree)란? + (백준 1992 쿼드트리)](https://hyo-ue4study.tistory.com/235)
- [스택 프레임](http://www.tcpschool.com/c/c_memory_stackframe)
- [수식 표기법 (feat. Stack)](https://velog.io/@coygyj/%EC%88%98%EC%8B%9D-%ED%91%9C%EA%B8%B0%EB%B2%95-feat.-Stack)

### 인터럽트

<br/>
<p align="center">
<img width="700" alt="스크린샷 2022-06-12 오전 11 53 41" src="https://user-images.githubusercontent.com/80025242/173212475-7ab71b8d-78f1-4d9c-89a0-d785fe347f15.png">
</p>
<br/>

- 첫 번째 방법의 문제점  
  쿠키를 다 만들기 전까지는 소포를 받아볼 수 없다.

<br/>

- 두 번째 방법의 문제점  
  쿠키를 만드는 모든 단계마다 소포가 왔는지 안 왔는지 확인하는 시스템. (`polling` 이라고 부름)  
  소포를 못 받을 가능성은 줄어들지만, 문 앞에 누가 왔는지 검사하는데 너무 많은 시간을 소모하게 된다.

<br/>

- 결론  
  소프트웨어적으로 이 문제를 해결할 수 있는 방법은 없다.  
  때문에, 실행 중인 프로그램을 잠깐 중단(`interrupt`)시키고 외부의 요소에 대응할 수 있게 하는 방법이 존재한다.  
  <br/>
  ```
  우선적으로 처리해야하는 태스크가 있어서 프로그램의 실행을 잠깐 중단하는 것을 '인터럽트한다' 라고 표현.
  ```

<br/>

### 인터럽트 시스템

<br/>

요즘 쓰이는 프로세서 대부분은 인터럽트(`interrupt`) 시스템이 들어간다.  
인터럽트 시스템은 적절한 신호가 들어오면 CPU 실행을 잠깐 중단할 수 있는 `핀`이나 `전기 연결`을 포함한다.

<br/>

### 인터럽트 시스템 동작 원리

<br/>

```
1. 인터럽트 요청 신호 발생
2. 프로그램 실행 중단 : 보통은 현재 실행중인 명령까지는 끝까지 수행함
3. 현재 프로그램 상태 보존 : PC는 항상 다음번 실행할 명령의 주소를 가지고 있음
4. 인터럽트 처리 루틴 실행 : 인터럽트 백터를 보고 (인터럽트가 발생한) 장치 식별
5. 인터럽트 취급(서비스) 루틴 실행 (실질적인 인터럽트 처리)
6. 상태 복구
7. 중단된 프로그램 실행
```

<br/>

`4`,`5`번이 `인터럽트 핸들러`에 해당하는 작업이다.

<br/>

- 인터럽트 시스템은 서비스 후 돌아올 프로그램의 위치를 어디에 저장하는가 ?  
  `Stack`에 저장한다. 인터럽트 핸들러는 자신이 덮어쓸 레지스터를 모두 저장해야 할 책임이 있다.

<br/>

- 컴퓨터는 어떻게 `인터럽트 핸들러`의 위치를 찾는가 ?  
  보통은 인터럽트 핸들러의 주소를 저장하기로 약속한 메모리 주소가 존재한다.  
  이 주소에 여러 `인터럽트 백터`가 들어있고, 인터럽트 백터는 CPU가 지원하는 각 인터럽트에 대한 핸들러 주소를 저장한다.  
  `인터럽트 백터`는 메모리를 가리키는 `포인터`이다.

### 상대 주소 지정

<br/>

여러 프로그램을 동시에 실행하기 위해서는,  
각 프로그램을 서로 전환시켜 줄 수 있는 `관리자 프로그램`이 필요하다.  
이런 프로그램을, `운영 체제` 또는 `커널(kernel : 중심)` 이라고 부른다.

<br/>

`OS` : 시스템 프로그램

`OS가 관리하는 프로그램` : 사용자 프로그램 / 프로세스

<br/>
<br/>

### 주소지정방식의 종류

<br/>

<p align="center">
<img width="300" alt="스크린샷 2022-06-12 오후 4 38 18" src="https://user-images.githubusercontent.com/80025242/173223854-938d2d63-ab4b-4905-afdc-484eb86fb703.png">
</p>

<br/>

<b> 1. `암시적` 주소지정방식 (Implied Mode) </b>

: 0주소 (`스택`)

<br/>

<b> 2. `즉시적` 주소지정방식 (Immediate Mode) </b>

: 메모리에 `실제 데이터`가 들어있음  
: 별도의 기억 장소에 엑세스하지 않고 CPU에 바로 접근하기 때문에 실행 속도가 빠름  
: 명령어의 길이에 영향을 받으므로 표현할 수 있는 실제 데이터 값의 길이가 제한적임

<br/>

<b> 3. `직접` 주소지정방식 (Direct Mode) </b>

: 메모리에 실제 데이터를 가리키는 `주소`가 들어있음  
: 주소 부분에 실제 사용할 데이터의 유효 주소를 적기때문에 주소 길이의 제약을 받음

<br/>

<b> 4. `간접` 주소지정방식 (Indirect Mode) </b>

: 메모리에 실제 데이터를 가리키는 `주소의 주소`가 들어있음  
: 명령어의 길이가 짧고 제한적이어도 긴 주소에 접근 가능한 방식

<br/>

5. 계산에 의한 주소지정방식

: `Operand`부와 `CPU`의 특정 레지스터 값이 더해져서 유효 주소를 계산하는 방식

- 상대 주소 (Relative Mode)  
  : 유효 주소 = 명령어의 주소 부분 + PC
- 베이스 레지스터 (Base Register Mode)  
  : 유효 주소 = 명령어의 주소 부분 + 베이스 레지스터
- 인덱스 레지스터 (Index Register Mode)  
  : 유효 주소 = 명령어의 주소 부분 + 인덱스 레지스터

# 메모리 관리 장치

- 컴퓨터는 멀티태스킹을 위해 백그라운드에서 통신작업이 실행됨.

- 하지만 메모리는 비싸고 공간이 한정적이다.

- 이를 위해 가상 메모리를 만들고 가상 메모리 주소를 실제(물리) 메모리 주소로 변환해주는 역할을 할 `MMU`를 만들게 됨.

- MMU가 들어 있는 시스템은 `가상 주소`와 `물리 주소`를 구분한다.

- `MMU`는 memory management unit의 약자로, 메모리 관리의 핵심적인 역할을 담당한다.

<그림. CPU와 메모리 처리 관계>

<img width="500" alt="image" src="https://user-images.githubusercontent.com/91880235/172491590-3f9a2270-9eb9-414c-9458-2fca42817018.png">

<br>

> ### MMU 처리방식 예시

CPU가 논리 주소 346 값을 요청하면 MMU는 `Base Register` 14000을 더해서 물리주소인 14346을 통해 메모리에서 실제 주소를 받는다.

<img width="499" alt="image" src="https://user-images.githubusercontent.com/91880235/172615006-c0cae562-471a-4d96-b3b0-613901df4a4c.png">

<br>

> ### 연속 메모리 할당(Contiguous Allocation)

- 커널이 저장되는 영역을 제외한 남은 공간에 사용자의 프로세스를 연속적으로 저장
- `베이스 레지스터`에는 프로세스의 시작 주소가 저장
- `리미트 레지스터`에는 프로세스의 길이가 저장됨
- `리미트 레지스터`길이를 초과하면 주소 에러를 내보냄

<img width="582" alt="image" src="https://user-images.githubusercontent.com/91880235/172615457-fffb29e1-b3df-464e-972e-e6445c09040b.png">

<img width="688" alt="image" src="https://user-images.githubusercontent.com/91880235/172615722-0ceeedca-f591-4832-9ab8-b9236bef3149.png">

<img width="624" alt="image" src="https://user-images.githubusercontent.com/91880235/172615793-87dba5f4-5e4c-4fc1-a5ed-b305b8758b51.png">

프로세스가 종료되면 메모리 공간에 종료된 프로세스 길이만큼 빈 공간(memory hole)이 발생 됨

이 빈공간 처리에 대한 부분은 아래와 같이 3가지 방법으로 처리할 수 있음.

1. `first-fit`: 첫번 째 빈 공간에 할당한다.
2. `best-fit`: 가장 적합한 빈 공간에 할당한다.
3. `worst-fit`: 가장 큰 빈 공간에 할당한다.
   best-fit이 worst-fit보다 좋은 것은 아니다(상황마다 다름)

<br>

> ### 외부 단편화(external Fragmentation)

- 빈 공간에 적합하거나 작은 프로세스를 할당하다보면 작은 공간이 무수하게 많아지는 경우가 발생.
- 다음 들어올 프로세스가 들어올 수 있는 메모리 공간에 있음에도 불구하고, 연속적이지 않고, 너무 많은 빈 공간들이 조각으로 남아있는 경우를 `외부 단편화`라한다.
- 대게 `best-fit`을 사용할 경우 발생하는 문제이다.

<img width="400" alt="image" src="https://user-images.githubusercontent.com/91880235/172618573-c04a3ac2-73e8-419f-a97e-a306a7490fc3.png">

<br>

> ### 페이징 기법(Paging)

- 외부 단편화를 해결하기 위해 페이징 기법이 구현됨.(인텔 프로세스에서 쓰이는 방법 hybrid로)
- 페이징 기법은 프로세스를 일정 크기인 `페이지`로 잘라서 비연속적으로 메모리에 적재하는 방식
- 페이지 번호(page number) `-p`와 페이지 참조 번호 (page offset)`-d`이 순서쌍 (p, d)으로 갖고 있다.

<img width="471" alt="image" src="https://user-images.githubusercontent.com/91880235/172619688-ad9c0772-5ba8-447b-88ca-aed5438af01a.png">

- `frame`과 `page`는 메모리를 일정한 크기의 공간으로 나누어 관리하는 단위로, 프레임과 페이지의 크기는 같다.
- `frame`: 물리 메모리를 일정한 크기로 나눈 블록
- `page`: 가상 메모리를 일정한 크기로 나눈 블록
- `페이징 테이블`: 프로세스의 페이지 정보를 저장하고 있으며, 하나의 프로세스는 하나의 페이지 테이블을 가진다.
- `페이징 기법`을 사용하면 비어있는 프레임 공간이 없어 외부 단편화를 발생시키지 않음. 허나 내부 단편화가 발생함

<br>

> ### 내부 단편화(Internal Fragment)

- 내부 단편화는 프로세스 크기가 페이지 크기의 배수가 아닐 경우 마지막 페이지는 한 프레임을 다 채울 수 없다. (100%19 = 5)
- 이로 인해 발생하는 공간은 결국 메모리 낭비로 이어진다.
- 내부 단편화는 해결할 방법이 없지만 외부단편화에 비해 낭비되는 공간이 매우 적다. <u>이는 무시할 정도로 작은 크기이다.</u>

<img width="500" alt="image" src="https://user-images.githubusercontent.com/91880235/172619377-c99b1420-81e4-44b9-9a71-fd3531eee477.png">

<br>

> ### TLB(Tanslation Look aside Buffer)

- `페이징 기법`을 사용하면 메모리에 2번 접근해야 한다.(page table에 접근 1번, 메모리에 접근 1번)
- 이 부분을 `MMU`에서 해결하기엔 비용이 비쌈
- 그래서 TLB라는 캐시 메모리 버퍼를 MMU 안에다 두어
  자주 사용하는 주소를 hit을 하는 방식으로 해결

  <img width="500" alt="image" src="https://user-images.githubusercontent.com/91880235/172723908-f068ab38-e04b-4311-9e1a-187668f59e5c.png">

<br>

> ### 참고

- [[운영체제/OS] Memory Management - MMU - paging - TLB - 컴도리돌이](https://comdolidol-i.tistory.com/243)
- [[운영체제 OS] Fragmentation 메모리 단편화란 무엇인가?](https://jhnyang.tistory.com/264?category=815411)
- [MMU(Memory Management Unit)에 관한 간단한 정리.](https://m.blog.naver.com/sungeuns/50098147696)

# 가상 메모리

- OS는 `MMU`를 사용해 메모리가 실제 메모리보다 많아 보이게 하는 기술인 가상 메모리를 제공한다.
- 메모리의 일부분을 디스크에 저장하여 사용하는 `디스크 스왑`이라고 불리는 것과는 별개의 기술이다.

  (Windows에서 디스크 스왑 설정을 "가상 메모리" 라고 번역 해놓아 혼동..)

`장점`은 아래와 같이 3가지다.

1.사용자가 기억장소를 일일히 할당하는 불편을 없애준다.

2.프로세스의 크기가 실제 메모리의 용량을 초과해도 실행될 수가 있다.

3.설사 물리적 메모리의 용량이 충분히 크다하더라도 다중 프로그래밍이 가능하다.

<br>

> ### 가상 메모리와 MMU의 관계

<img width="600" alt="image" src="https://user-images.githubusercontent.com/91880235/172724924-5f1d7772-8036-44f9-87f6-68b4fcd3c282.png">

- `CPU`는 `가상 메모리 주소`만을 다루고, 실제 해당 주소 접근 시 `MMU`를 통해 물리 메모리에 접근
- 하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 `MMU`라는 별도의 장치를 두고 있는 것
- `페이징 시스템`을 사용하면 프로세스에서 나눠진 page를 언제 물리 메모리에 올려놓을지에 대한 정책이 필요 -> `요구불 페이징`

<br>

> ### 요구불 페이징(Demand Paging)

- `Demand Paging`: 프로세스의 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재함. 이 때 `valid/Invalid bit`가 사용된다.

- `Invalid/Valid Bit`: 사용되지 않는 주소 영역인 경우, 페이지가 물리적 메모리에 없는 경우 (valid는 반대)
  처음에는 모든 page가 invalid로 초기화되고, 사용되면 valid로 되는데, address translation시에 invalid bit이라면 `page fault`가 발생한다.

- `Page fault`: 어떤 페이지가 물리 메모리에 없을 때 발생하는 인터럽트로, `Page fault`가 발생하면 운영체제가 해당 페이지를 물리 메모리에 올려준다.

- `Swap Out`: 요청받은 메모리가 사용 가능한 메모리의 크기보다 크다면 현재 필요 없는 페이지를 느리지만 용량이 큰 디스크로 옮김
- `Swap In`: `Swap Out`한 페이지로 접근이 필요하면 메모리 공간을 확보하고 해당 페이지를 다시 메모리로 불러들이는 것
  이런 식으로 페이지 처리하는 것을 `요구불 페이징(Demand Paging)` 이라고 한다.

<br>

> ### 페이지 교체 정책(Page Replacement policy) 알고리즘

운영체제가 특정 페이지를 물리 메모리에 올리려고 하는데 물리 메모리가 다 차있다면?

기존 페이지 중 하나를 물리 메모리에서 저장 매체로 내리고(저장)

새로운 페이지를 해당 물리 메모리 공간에 올려야한다.

이 때 어떤 페이지를 물리 메모리에서, 저장 매체로 내릴 것인가에 대한 것이 `페이지 교체 정책`이다.

1. `FIFO 알고리즘`: 가장 먼저 들어온 페이지를 내린다. (Queue)

<br>

2. `OPT(OPTimal) 알고리즘`: 앞으로 가장 오랫동안 사용하지 않을 페이지를 내린다는 최적 페이지 알고리즘.그러나 미래에 어떤 페이지를 얼마나 사용할 것인지는 알 수 없으므로 일반 OS에서는 구현이 불가하다. (실제 구현보다는 비교 <u>연구 목적으로 사용</u>)

<br>

3. `LRU(Least Recently Used) 알고리즘`: 가장 오래전에 사용된 페이지를 내리자! 라는 아이디어로, 과거 기록을 기반으로 시도한 것이다. <u>많은 운영체제가 택하는 알고리즘</u>으로 좋은 알고리즘이라 평가받고 있다.

<br>

4. `LFU(Least Frequently Used) 알고리즘`: 가장 적게 사용된 페이지를 내리자!

<br>

5. `NUR(Not Used Recently) 알고리즘`: LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 내리자는 알고리즘인데, 각 페이지마다 참조 여부를 나타내는 비트(R), 수정 여부를 나타내는 비트(M)을 두어서 (0, 0), (0, 1), (1, 0), (1, 1) 순으로 교체한다.

<br>

> ### 참고

- [[운영체제] 가상 메모리의 이해](https://libertegrace.tistory.com/m/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%9D%B4%ED%95%B4)
- [페이지 교체(page-replacement) 알고리즘](https://medium.com/pocs/%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-page-replacement-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-650d58ae266b)
- [가상메모리-나무위키](https://namu.wiki/w/%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC)

# 시스템 공간과 사용자 공간

하드웨어인 MMU의 설정을 마음대로 바꿀 수 있거나, 운영체제가 설정하는 초당 인터럽트 발생 횟수 등을 유저가 조작한다면 프로그램이 비정상적으로 작동할 확률이 크다.

이러한 문제를 해결할 수 있는 추가 하드웨어를 제공한다.
CPU에는 컴퓨터가 `시스템 모드`에 있는 지 `사용자 모드`에 있는 지 결정하는 비트가 어떤 레지스터 안에 들어있다.

`트랩`이나 `시스템 콜`이라고 부르는 특별한 명령어를 통해 `시스템 모드 프로그램(운영체제)`으로 요청을 보낼 수 있다.

- `트랩`: - Register와 스택 포인터가 저장되고, Context Switching이 일어나고, 실행이 재개될 수 있다는 면에서 인터럽트와 굉장히 흡사하다. 그래서 이를 CPU 내부 인터럽트라고도 한다.

- `시스템 콜`: 커널 기능을 커널에 요청하는 방식. Trap을 통해서 실제로 커널에 정보가 전달된다. System Call은 그 Interface라고 할 수 있음.

<br>

> ### 커널과 시스템 프로그램

- 운영체제는 `커널`과 `시스템 프로그램`로 구분 될 수 있다.
- `커널`은 운영체제의 핵심으로 컴퓨터 자원들을 관리하는 역할을 한다.
- 사용자와 직접적인 상호작용을 위해서 `시스템 프로그램`이 필요하다.
- 시스템 프로그램의 예로 쉘(Shell)이라는 명령어 해석기가 있다.
- 쉘은 사용자가 컴퓨터에게 전달하는 명령을 해석하는 프로그램으로 사용자와의 상호작용을 가능하게 한다.

<br>

> ### 커널이 하는 일
>
> `커널`은 사용자가 `시스템 콜`을 통해 컴퓨터 자원을 사용할 수 있게 해주는 `자원관리자`라고 볼 수 있다.

- `태스크 관리자` : CPU를 task라는 추상적인 자원으로써 제공
- `메모리 관리자` : 메모리를 segment나 page로 제공
- `파일시스템` : 디스크를 파일로 제공
- `네트워크 관리자` : 네트워크 장치를 소켓으로 제공
- `디바이스 드라이버 관리자` : 각종 장치를 디바이스 드라이버를 통해 일관되게 접근하도록 함

<br>

> ### 참고

- [[linux kernel] (1) - 커널(kernel)이란?](https://jiravvit.tistory.com/entry/linux-kernel-1-%EC%BB%A4%EB%84%90kernel%EC%9D%B4%EB%9E%80-1)
- [[OS] System call, Interrupt, Trap, 등
출처: https://teraphonia.tistory.com/790 [Binceline:티스토리]](https://teraphonia.tistory.com/790)

- [System Call이란?](https://ju-hy.tistory.com/8)

# 메모리 계층과 성능

> ### 메모리 계층 구조란?

- 메모리는 가격과 성능이 비례하고 성능과 용량은 반비례한다.
- 각각의 특징이 있는 서로 다른 여러 종류의 저장 장치를 함께 사용하여 `최적의 효율`을 낼 수 있게 `가격 대비 좋은 성능`의 컴퓨터를 구현하기 위함

<img width="601" alt="image" src="https://user-images.githubusercontent.com/91880235/173183504-520672c9-aedc-4748-a2f7-b53ea98d35cd.png">

<br>

> ### 컴퓨터 메모리의 종류

### 1. 레지스터

- 컴퓨터에서 제일 빠른 메모리로, CPU 계산 과정에서 작동한다.
- 컴퓨터에서 4대 주요 기능(기억, 해석, 연산, 제어)을 관할하는 장치
- CPU는 자체적으로 데이터를 저장할 방법이 없으므로 메모리로 직접 데이터를 전송할 수 없음

  → 연산을 위해서 반드시 레지스터를 거쳐야 하며, 이를 위해 레지스터는 특정 주소를 가리키거나 값을 읽어올 수 있음

- CPU 내부 레지스터 종류로는 `프로그램 카운터`, `누산기`, `명령어 레지스터`, `상태 레지스터` 등이 있다.

<br>

### 2. 캐시 메모리

- 레지스터 다음으로 빠른 메모리로, CPU와의 거리에 따라 `L1 ~ L3 캐시` 등 여러 단계로 나뉜다.
- 데이터나 값을 미리 복사해 놓는 임시 장소로, 보통 <u>SRAM</u>으로 구성되며 숫자가 작을수록 CPU에 가까운 상위레벨 캐시로 용량이 작고 빠르다.
- 속도가 빠른 장치와 느린 장치 사이에서 속도차에 따른 <u>병목 현상을 완화</u>하기 위한 범용 메모리

### 2-1 캐시메모리의 지역성:

- 데이터 접근이 시간적, 혹은 공간적으로 가깝게 일어나는 것
- 캐시가 효율적으로 동작하기 위해서는 캐시가 저장할 데이터가 지역성을 가져야 함

| 종류          | 설명                                                                                      |
| ------------- | ----------------------------------------------------------------------------------------- |
| 시간적 지역성 | 특정 데이터가 한 번 접근되었을 경우, 가까운 미래에 또 한 번 데이터에 접근할 가능성이 높음 |
| 공간적 지역성 | 액세스 된 기억장소와 인접한 기억장소가 액세스 될 가능성이 높음                            |

<br>

### 3. 메인 메모리

- CPU, 메인보드와 분리되어있는 메모리 중 `최상위 메모리`로 `RAM`과 `ROM`이 해당
- 컴퓨터가 빠른 액세스를 하기 위해 데이터를 단기간 저장하는 구성 요소
- 사용자가 요청하는 프로그램이나 문서를 스토리지에서 메모리로 로드하여 각각의 정보에 액세스
- 스토리지(SSD, HDD)와 비교하면 차원이 다르게 빠름

<br>

### 4. 스토리지 (SSD, HDD)

- `보조 기억장치`로 불린다.
- 주로 ATA(Advanced Technology Attachment, 고급기술결합)라는 중간 인터페이스 규격과 연결되어 통신한다.
- NVMe SSD는 CPU와 직접 통신한다.

<br>

### 5. 이동식 저장장치

- USB 메모리, ODD 등을 의미
- 기업용으로는 자기 테이프 등..

<br>

> ### 참조의 지역성

- 컴퓨터 프로그램은 메모리의 같은 지역을 자주 확인하는 경향이 있다.
- 게임을 예로 들어 `메이플스토리`라는 게임을 플레이한다면 바뀌지 않는 `맵`을
  비싼 CPU에 올릴 필요는 없다. 그래서 RAM에 올려두고 유동적으로 움직이는 `캐릭터`를 빠른 캐시에 올려다 주면 된다.

<br>

> ### 참고

- [메모리 계층구조 - 나무위키](https://namu.wiki/w/%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B3%84%EC%B8%B5%20%EA%B5%AC%EC%A1%B0)
- [ATA - 나무위키](https://namu.wiki/w/Advanced%20Technology%20Attachment)
- [[OS] 메모리 계층 구조(Memory Hierachy)](https://velog.io/@yu-jin-song/CS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0)

# 코프로세서

### 코프로세서(coporcessor)

`코프로세서`는 보조프로세서 또는 보조 처리기 라고도 부른다.  
부동소수점 산술, 그래픽, 신호 처리, 문자열 연산, 암호화, 주변장치 입출력 등의 프로세스 코어에 비해 단순한 기능을 담당한다.  
프로세스 코어에 집중된 기능들 중 단순 처리하며 부담을 덜어주는 역할을 한다.

### 참고

- [코프로세서 - 위키백과](https://ko.wikipedia.org/wiki/%EC%BD%94%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C)

# 메모리 상의 데이터 배치

### 정적(static) 데이터

프로그램 작성 시 얼마나 많은 메모리가 필요한지 알고 있는 데이터  
서로 메모리가 충돌하지 않도록 배치 할 수 있다.

### 동적(dynamic) 데이터

프로그램을 실행하기 전에는 크기를 알 수 없는 데이터  
동적 데이터는 정적 데이터가 차지하는 영역 바로 위에 쌓이고 이를 `힙(heap)`이라고 부른다.

![메모리](https://user-images.githubusercontent.com/91672778/173217747-972d456e-598a-46dd-a21e-165485db09b8.png)

### 힙(heap)

동적으로 할당하는 메모리 공간으로 힙 영역이 커지다가 스택 영역을 침범하면 heap overflow라고 한다.

### 참고

- [메모리 영역, 정적 메모리 할당, 동적 메모리 할당](https://blog.naver.com/parkjy76/220925369874)

# 프로그램 실행

프로그램이 실행될 때 먼저 `런타임 라이브러리(runtime library)`가 실행되고 프로그램의 `진입점(entry point)`의 명령어가 실행된다.

### 라이브러리(library)

소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임이다.  
구성 데이터, 문서, 도움말 자료, 메시지 틀, 미리 작성된 코드, 서브루틴(함수), 클래스, 값, 자료형 사양을 포함할 수 있다.

### 링커(linker)

여러 파일들을 병합해 하나의 프로그램으로서 실행시키는 프로그램

![image](https://user-images.githubusercontent.com/91672778/173220643-d63787e5-e0cd-4584-92e9-9c385674267f.png)  
**정적 링크(static link)**

> 실행 파일과 정적 라이브러리 파일을 모두 복사해 하나의 실행 파일로 만들어 메모리에 올린다.  
> 자주 사용되는 라이브러리가 있다면 계속해서 실행파일에 추가되기 때문에 메모리를 낭비하게 된다.

**동적 링크(dynamic link)**

> `공유 라이브러리(shared library)`주소만 가지고 있다가  
> 메모리에서 실행파일이 실행되면서 라이브러리가 필요하면 메모리에 올린다.  
> 여러 곳에서 해당 라이브러리를 참조해 사용할 수 있다.

### 런타임 라이브러리(runtime library)

여러 파일들이 하나로 합쳐져서 실행파일이 생성될 때 추가된다.  
스택과 힙의 영역을 설정하고 정적 데이터가 위치한 데이터의 초기값 등을 설정하는 역할을 한다.

### 진입점(entry point)

프로그램의 첫 번째 명령어가 위치한 주소

# 메모리 전력 소비

데이터를 메모리에서 옮기려면 `전력(power)`이 소모된다.  
모바일 장치에서나 대형 인터넷 회사와 같은 곳은 전력 소비와 성능 사이의 균형을 잘 잡아야한다.
