# Ch10. 애플리케이션 프로그래밍과 시스템 프로그래밍

## 프로그램 개요

컴퓨터가 사용자에게 몇 가지 질문을 던지면서 동물을 맞추는 게임

<img src="https://user-images.githubusercontent.com/91672778/206884479-adbcd608-bd94-4766-b5cb-8f76cb829fa1.jpeg" width="500"/>

## 자바스크립트

```
var node; // 지식 트리상의 현재 위치

// 제공받은 html을 대화에 추가한다. 새 노드에 자식이 없다면
// 더 이상 질문할 내용이 없으므로 끝낸다. 새 노드에 자식이 있다면,
// 새 노드를 현재 노드의 자식으로  만들고 노드의 string 애트리뷰트를 사용해
// 질문을 던진다. 노드가 잎 노드이면 질문으로 동물 이름을 던진다.
// 새 노드가 잎 노드이면 true를 반환한다.

function
question(new_node, html)
{
  $('#dialog').append(html);      // html을 대화에 추가함

  if ($(new_node).length == 0) {  // 자식이 없으면 질문도 없음
    return (true);
  }
  else {
    node = new_node;

    if ($(node).children().length == 0)
      $('#dialog').append($(node).attr('string') + '입니까?');
    else
      $('#dialog').append($(node).attr('string') + '?');

    return (false);
  }

// 게임을 다시 시작한다. 모든 버튼과 텍스트 필드를 감추고, 텍스트 필드를
// 지우고, 초기 노드와 인삿말을 설정한 다음, 첫 번째 질문을 던지고,
// 예/아니오 버튼을 표시한다.

function
restart()
{
  $('.start-hidden').hide();
  $('#question,#what').val('');
  question($('#root>div'), '<div><b>동물을 생각해보세요.</b></div>');
  $('#yesno').show();
}
```

`$()` Jquery selector

브라우저가 해당 자바스크립트 파일을 읽어와 Html 파일에서 실행해 준다.

## 동물 추측 게임 버전2: C 프로그램

브라우저는 고수준 가상 머신이다. C언어로 프로그램을 작성하면서, 브라우저가 숨겨주는 운영체제의 기초적인 동작을 알아본다.(유닉스에서 파생된 운영체제이다.)

### 터미널과 명령줄

- 그래픽 사용자 인터페이스(GUI)
  - GUI는 주로 제스처 언어를 사용한다.
- 명령줄 인터페이스 (CUI)
  - 터미널 애플리케이션을 통해 명령 프롬프트를 확인할 수 있다.

### 프로그램 빌드

- C는 컴파일 언어이므로 소스 코드를 기계어로 변환해야 한다.
- 이 변환 과정을 `빌드`라고 한다.

```bash
cc gta.c -o gta
```

- `cc`: C 컴파일러
- `gta.c`: 소스 파일 이름
- `-o`: 출력 파일 이름이 -o 다음에 온다.
- `gta`: 출력 파일 이름

### 터미널과 장치 드라이버

- 사용자 프로그램은 직접 `I/O 장치`와 통신하지 않고, `운영체제`가 통신을 중재한다.
- 터미널 소프트웨어가 I/O장치와 통신하는 과정은 다음 그림과 같다.
  ![그림 10-6](https://cdn.discordapp.com/attachments/879215554379018243/1010602485863432222/unknown.png)
- 이전에는 터미널을 컴퓨터와 직렬 연결하는 물리적인 선이 존재했다.
- 오늘날 운영 체제는 이런 연결이 진짜 존재하는 것처럼 소프트웨어로 흉내내어 동작한다.

### 문맥 전환 (Context switching)

- 레지스터 집합은 컴퓨터에서 하나 뿐이다. 운영체제는 한 사용자의 프로그램을 다른 사용자 프로그램으로 바꿀 때마다 레지스터를 저장하고 복구해야한다.
- 저장하고 복구해야 하는 모든 내용을 `프로세스 문맥 (process context)` 이라고 한다.
- 문맥의 크기가 커서 문맥 전환의 비용이 비싸기 때문에 `시스템 콜`은 아래와 같이 이루어진다.
  ![그림 10-7 문맥 전환](https://media.discordapp.net/attachments/879215554379018243/1010602340258152538/unknown.png)

- 물리적 장치와 관련된 처리를 담당하는 `장치 드라이버`는 터미널에 들어오는 문자를 `버퍼`에 저장하고, 사용자가 키를 누를 때가 아닌, Enter를 누를 때만 사용자 프로그램을 깨운다.

#### 버퍼

- 선입선출(FIFO) 데이터 구조
- 사용자의 키 입력은 프로그램이 디스플레이에 보내는 출력보다 느리기 때문에 `입력 버퍼`와 `출력 버퍼`가 필요하다.
- 출력 버퍼가 다 차도 프로그램이 터미널에 출력을 시도하면 프로그램을 슬립 상태로 전환한다.

![그림 10-9 터미널 장치 드라이버의 버퍼링과 메아리](https://media.discordapp.net/attachments/879215554379018243/1010601902297337866/unknown.png)

### 표준 I/O

표준 입력/출력 라이브러리 (standard input/ouput, stdio) 에는 사용자 프로그램이 사용할 수 있는 버퍼 I/O 함수가 들어있다.
![그림 10-10 stdio 버퍼를 사용하는 사용자 프로그램](https://cdn.discordapp.com/attachments/879215554379018243/1010601598151557160/unknown.png)

- 버퍼 입력을 지원하여 시스템 콜을 한 번만 사용해 데이터를 `버퍼`에 넣는다.
- 사용자 프로그램은 버퍼가 빌 때까지 버퍼에 `입력 문자`를 얻는다.
- 버퍼가 소진되면 다시 시스템 콜을 통해 입력을 더 가져온다.
- 출력하는 경우 버퍼가 꽉 차거나 중요한 문자가 출력될 때까지 문자가 버퍼에 들어간다.

이렇게 입출력을 효율적으로 하기 위해 많은 일을 한다.

### 원형 버퍼

![그림 10-14 원형 버퍼](https://cdn.discordapp.com/attachments/879215554379018243/1010601789055311965/unknown.png)

- in과 out은 원소를 가리키는 포인터이다.
- in 화살표가 시계방향으로 out 화살표를 따라잡기 전까지는 큐에 원소를 추가할 수 있다.
- out 화살표가 시계방향으로 in 화살표를 따라잡기 전까지는 큐에 원소를 제거할 수 있다.
- 화살표의 다음 위치는 현재 위치에 1을 더한다음 버퍼 크기로 나눈 나머지이다.
- stdio나 장치 드라이버 그 외에도 표준적으로 많이 쓰이는 방식이다.

## 동물 추측 게임버전 2: C 프로그램(2)

### 추상화를 활용한 코드 개선

C 프로그램으로는 앞의 동물 추측 게임에서 마지막 게임 상태를 저장했다가 다시 불러와 게임을 수행할 수 있다. 이는 `파일 추상화`로 인한 부수적인 장점이라고 할 수 있다.
이런 기능을 자바스크립트로 구현하기는 쉬운 일이 아니다.

운영체제는 파일과 장치에 대해 똑같은 인터페이스를 제공한다. 브라우저나 C 프로그램 버전 모두에서 동일하게 사용된다.
이 말은, C 프로그램은 브라우저처럼 파일에서 입력을 받는 코드를 장치에서 입력을 받는 부분에 쓸 수 있다는 뜻이다.

하지만 브라우저는 자바스크립트를 통해 추상화를 개발자에게 넘기지 않고, 다른 인터페이스의 다른 코드를 사용해서 새 기능을 추가해야 한다.
이처럼 인터페이스의 선택은 프로그래밍의 편의와 결과의 명확성에 큰 영향을 끼친다.

<br></br>

### 런타임 라이브러리와 표준 입출력

C 프로그램을 실행하기 위해서는 코드를 컴파일한 다음, 컴파일이 된 코드와 해당 코드가 사용하는 stdio 라이브러리 등의 다른 코드를 링크(link)해야 한다.
이처럼 `런타임 라이브러리`도 포함해야 하는데, 런타임 라이브러리는 스택과 힙을 설정해서 사용할 수 있도록 준비하는 등의 설정을 담당하며, 터미널 장치 드라이버와 연관된 파일을 입력과 출력을 위해 연다.

`stdio` 라이브러리는 시스템 파일 디스크립터를 파일 포인터(file pointer)와 연관시킨다. `파일 디스크립터`는 프로세스에서 특정 파일에 접근할 때 사용하는 추상적인 값이며, `파일 포인터`는 버퍼링이나 파일 관리에 필요한 데이터 구조를 가리킨다.
stdio는 `stdin(표준 입력)`, `stdout(표준 출력)`, `stderr(표준 오류 출력)` 3가지 파일 포인터를 제공한다.
프로그램이 프로세스로 메모리에서 실행될 때, 표준 입력(Standard Input), 표준 출력(Standard Output), 표준 에러(Standard Error)에 각각 `0, 1, 2`라는 정수가 할당된다.

그리고 stdout과 stderr는 똑같은 대상으로 데이터를 내보내지만, stderr는 버퍼를 사용하지 않고 stdout은 버퍼를 사용한다. 버퍼로 보낸다면 프로그램이 중단될 때까지 표시되지 않을 수 있다.

<br></br>

### 버퍼 오버플로(Buffer overflow)

버퍼 오버런(buffer overrun)이라고도 하며, 메모리를 다루는 데에 오류가 발생해 잘못된 동작을 일으키는 프로그램의 취약점이다.
단어 그대로 버퍼가 흘러넘쳐 발생하는 것으로 데이터를 메모리에 저장할 때 개발자가 지정한 메모리의 바깥 쪽에 저장하는 것이다.
즉, 선언된 크기보다 더 큰 데이터를 기록해 발생하는 현상이다.
이렇게 벗어난 데이터는 가까운 메모리를 덮어쓰게 되는데, 해당 메모리에 다른 데이터가 저장되어 있을 수 있다.
이로 인해 메모리 접근 오류, 프로그램 종료 또는 시스템 정보 노출 등이 발생할 수 있다.

이는 보통 데이터를 저장하는 과정에서 저장될 메모리 위치가 유효한지 검사하지 않아서 발생한다고 한다.
데이터의 크기를 확인하지 않고 데이터를 저장하는 함수를 사용하는 경우, 버퍼의 크기를 초과하여 데이터를 저장한다.
데이터를 저장할 때, 스택 베이스 주소를 가리키는 레지스터를 넘어서는 메모리 공간까지 침범하게 되고, 만일 해당 메모리에 해커가 악의적으로 다른 메모리 공간의 주소와 같은 악성코드를 넣으면 스택 오버플로우가 발생한다.

<br></br>

### 참고 자료

- [파일 디스크립터(File Descriptor) 란 무엇인가?](https://twofootdog.tistory.com/51)
- [버퍼 오버플로우(Buffer Overflow)](https://byounghee.tistory.com/20)
