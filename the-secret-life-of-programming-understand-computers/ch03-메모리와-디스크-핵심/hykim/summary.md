# 컴퓨터는 비트를 어떻게 기억하는가

<br/>

### 순차논리와 조합논리

순차논리라는 말은 순서(sequence)라는 말에서 비롯된 용어이다.
순서는 '시간적으로 어떤 값 뒤에 오는 다른 값' 이라는 뜻이다. 사람은 손가락으로 수를 셀 때처럼 직관적으로 시간에 대해 알지만, 사람이 직관적으로 시간을 안다고 해서 디지털 회로에서도 시간을 자연스럽게 다룰 수 있다는 뜻은 아니다. 
조합논리는 입력의 현재 상태만을 다룬다. 하지만 순차 논리는 입력의 현재 상태와 과거 상태를 함께 고려한다.


<br/>


## 시간 표현과 상태 기억
### 발진자 (p.136)
가장 먼저 소개 되는 시간을 측정하는 기준은 "발진자, oscillater"이다. 이 발진자의 핵심 원리는 되먹임(feedback)인데, 인버터, inverter의 출력을 입력으로 연결했을 때를 생각할 수 있겠다. (마이크와 스피커를 가까일 가져가면 하울링 되는)

이 아이디어를 갖고 적은 비용으로 안정적인 주파수를 만드는 발진자의 재료로 크리서털, crystal이다. 크리스털과 전기의 반응을 이용해 (피에조 전기 효과 or 압전 효과) 음성 진동을 잡아내거나 만들어낼 수 있었다.

전자적인 단극쌍투 스위치를 사용해 크리스털에 전기를 가해서 다시 전기를 얻어낸다. 입력한 전기로부터 크리스털이 전기를 다시 만들어내는 시간은 예측이 가능하며 매우 정확하다. (특히 석영quartz라는 크리스털이)

<br></br>

### 클록 (p.137)
발진자는 컴퓨터에 클록(clock, 시간을 셀 수 있게 해주는 신호)를 제공한다.
이 클록은 회로의 페이스(pace)를 결정한다. 이 클록의 페이스를 최대로 끌어낸다면, 회로가 작업할 수 있는 최대 속도로 작업한다면, 전파 지연에 따라 이 속도가 결정되겠다.

비닝(binning)을 통해 부품을 측정해 그 특성에 따라 여러 다른 빈이나 무더기로 분류한다. -> 이런 이유로 부푼의 전파 지연 시간을 표시할 때도 범위를 사용한다. (무한히 많은 빈을 만드는것은 실용적이지 못하니)

오버클로킹이란 단어도 통계적으로 빈의 중간 정도에 위치하는 부품을 부품이 고장 나지 않을 범위 안에서 클록을 빠르게 공급하는 도박을 한다는 뜻이다.

<br></br>

### 래치 (p.138)

0과 1을 다루는 정보 1비트를 기억하는 방법 중 하나로 래치를 사용하는 방법이 있다. 래치는 비트를 임시로 저장할 수 있는 소자 중 하나다. 2개의 게이트로 구성되며, 게이트 하나의 출력이 다른 게이트의 입력으로 다시 연결되는 피드백 연결 형태를 갖고 있다.
단순 OR 게이트 래치는 출력이 1이 되는 순간부터는 다시 0으로 되돌릴 방법이 없다. 따라서 되먹임을 끊고 회로를 재설정(reset)하는 장치가 필요하다.

reset-bar가 로우이면 reset은 하이이므로, OR 게이트의 풀력은 OR 게이트의 입력에 되먹임이 깨진다.
S-R 래치 : 액티브 로우 입력을 받고 보수(complementary)출력을 제공한다. (출력의 한쪽은 액티브 하이, 다른 쪽은 액티브 로우)

- 장점 : 위에 AND-OR 게이트를 엮어 만든 래치 보다 대칭적이다. (set과 reset 신호의 지연 시간이 거의 비슷)
- 단점 : 초기값을 알 수 없고 영향을 많이 받아 (예측이 안되기 때문에), 초기값 설정이 필요하다.

### 게이트가 있는 래치 (p.140)
게이트가 있는 S-R 래치 : S-R 래치 입력에 OR 게이드 한 개씩 추가한 래치. gate-bar 입력값이 거짓(하이)인 경우 상관없이 출력이 1이 된다.

게이트가 있는 D래치 : gate-bar 입력 외 다른 입력을 D로 넣은 래치. D 입력 중 하는 인버를 추가했다.

gate-bar가 참(로우)일때 출력을 통제 할 수 있지만, 그렇지 않을때는 결과가 불안정하다. (p.141)

<br></br>

### 플립플롭 (P.142)
위에 말했던 불안정한 결과를 안정화하기 위해 가장 일반적으로 사용하는 방법은 논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 것이다.

이런 전이를 에지(edge)라고 한다. 에지를 시간에 대한 판정 기준이라고 생각할 수 있다. 에지에 의해 데이터 변화가 촉발되는 래치(edge-triggered latch)를 플립플롭(flip-flop)이라고 한다.

플립플롭을 만들 때는 래치를 기본 요소로 사용한다. 3개의 S-R 래치를 연결해 양의 에지에 의해 변화가 촉발되는(positive edge-triggered)플립플롭을 만들 수 있고 이를 D플립플롭이라고 한다.

논리 수준이 0에서 1로 바뀌는 순간에 플립플롭의 출력이 바뀐다는 뜻이다.
음의 에지에 의해 변화가 촉발되는 플립플롭은 논리 수준이 1에서 0으로 바뀌는 순간에 출력을 바꾸겠다. (자세한 동작 방식 p.143)

최초의 전자적 플립플롭의 역사와 스키매틱 기호, 동작 방식 (p.144)

에지에 의해 상태 변화가 촉발되는 장치의 상태 병화 타이밍을 볼때는 전파 지연 외레 요소도 고민해야 되고 이에 대한 해결책으로 설정 시간(setup time)과 유지 시간(hold time)이 있다.
<br></br>

### 카운터
플립플롭을 응용한 회로 중에는 순서대로 수를 세는 카운터(counter)가 있다.

예를 들어 디지털 시계를 만들고 싶다면 발진자에서 나온 시간을 세고, 그 값을 디코더에 공급해서 숫자를 표시하는 디스플레이를 제어하면 된다.
리플 카운터(ripple coutner) : 물에서 물결이 퍼져나가듯이 개수를 센 결과가 왼쪽에서 오른쪽으로 퍼져나가기 때문에 이렇게 부른다. 각 플립플롭의 D 입력이 자기 자신의 Q-bar 풀려에 연결되어 있기 떄문에, 각 플립플롭은 자신의 CK 신호가 0에서 1로 전이될 때마다 상태가 바뀐다.

각 비트의 상태가 다른 비트의 상태 변화에 약간의 시차를 두고 바뀌기 때문에 이 회로를 비동기 카운터(asynchronous counter)라고도 한다.
비동기 시스템은 언제 결과를 봐야 맞는지 알기 어렵다는 단점이 있다. (위에 카운터에서도 상태가 퍼져나가는 동안에는 올바르지 않겠다.)

리플 자리올림 가산기에서 봤던 것처럼, 동기적 카운터(synchronous counter)를 설계해서 리플 카운터의 타이밍 문제를 해결할 수 있다. (모든 플립플롭을 병렬로 연결)

<br></br>

### 레지스터 (p.147)
레지스터 (register) : 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것이다.

(p.147)에 가산기 회로로 덧셈한 결과를 레지스터에 저장하는 예시가 있다.
가장 큰 사용은 결과값 저장이겠다. 가산기 출력을 클록을 사용해 레지스터에 넣고 나면, 가산기의 입력을 바꿔도 결과는 바뀌지 않는다.

카운터에 있던 enable 입력 신호를 제공하는 경우도 자주 있다.
<br></br>
## 메모리 조직과 주소 지정
레지스터에 저장해야 되는 데이터 양보다 많은 양을 저장해야 되는 경우를 알아본다.

가장 쉬운 방법은 레지스터를 여러개 쌓아 올리는 것이겠다.

여기서 문제는 어떤 레지스터를 사용해야 할지 어떻게 지정해야 되나? 이다.
이를 위해 디코더를 사용해 레지스터에게 번호를 부여해 처리한다. 이 번호를 `주소(address)`라고 하낟.
그리고 지정한 주소에 해당하는 레지스터의 출력을 선택하기 위해 실렉터를 사용한다.
그리고 큰 관점, 시스템에서 여러 메모리 컴포넌트의 출력을 한 출력으로 연결해야 될 때가 있다. 이 때는 `트라이스테이트(tri-state)`를 사용한다.
(p.149)에 메모리 회로 스키매틱 기호

하지만 이런 메모리 컴포넌트는 연결 지점이 굉장히 많다. (비트 수 만큼 입,출력을 비트 수 만큼 연결해야 한다.)

하드웨어 엔지니어들은 이를 해결하기 위해 메모리를 동시에 읽고 쓸 필요가 없다는 성질을 활용해 연결을 줄였다.
입력과 출력 데이터를 (따로) 연결을 합지고 read/write-bar 제어 신호를 사용하여 연결을 줄였다.
여기 대량의 주소 연결 부분을 `주소 버스(address bus)`, 데이터 연결 부분을 데이터 `버스(data bus)`라고 한다.
그리고 또! 문제가 있다. 메모리 크기가 늘어나면 주소로 연결해야 할 비트 수도 많아진다. 책의 예시(p.150)에 보면 4GiB 메모리 컴포넌트의 경우 32개의 주소 연결이 필요하다. (2^32 이니)
주소는 행과 열의 두 덩어리로 나눈 디코더에서 메모리로 보낸다. (다시 말해 메모리에 한 디코더는 행 주소로, 다른 하는 열 주소로 보내는 것이다.)
이 문제는 `멀티플렉싱한 주소`를 저장한 레지스터를 디코더 전에 삽입해, 입력을 반토막 낼 수 있다.
(p.151)에 메모리 팁 크기 표기법, 성능 향상법 설명
<br></br>

### 임의 접근 메모리 (p.151)
위에서 말한 메모리 구조는 사실 `임의 접근 메모리(random access memory, RAM)`이다. RAM을 사용하면 메모리 위치 중 원하는 곳 어디든 순서로 쓰거나 읽을 수 있다.

- 정적, Static RAM : 비싸지만 아주 빠르다. 각 비트에 트랜지스터가 6개나 들어간다. 트랜지스터가 공간을 차지해서 대용량 비트를 저장하기에 적합하지는 않다.
- 동적, Dynamic RAM : 캐패시터(capacitor)라는 아주 작은 버킷에 전자를 담고, 트랜지스터를 1개만 사용해 뚜껑을 덮는다. (싸진다!, 저장 공간이 많아진다!) -> 저장 공간이 많으니 멀티플랙싱 레지스터 써야겠지?
    - 단점으로는 버킷이 새기 때문에 메모리를 갱신(refresh)해야 한다. -> 주기적으로 전자를 다시 넣어야 한다. (갱신 시점과 정보를 쓰는 시간이 겹치면 안되겠다.)
    - (책에서는 여러 사항들 때문에 라고 이유를 말해주진 않는다.) 행 주소 스트로브가 행 주소를 저장하는 것보다 열 주소 스트로브가 열 주소에 저장하는 것보다 빠르다. -> 프로그래밍에서 함께 사용되는 요소들을 같은 행에 넣어두면 성능이 훨씬 좋아진다.

위에 SRAM, DRAM은 휘발성(volatile) 메모리지만 
비휘발성(non-volatile) 메모리인 코어(core) 메모리는 토럿그 모양(도넛모양)으로 쇳조각에 저장한다. (p.152)

<br></br>

### 읽기 전용 메모리 (p.153)
한 번만 쓸 수 있는 읽기 전용 메모리(Read-Only Memory, ROM)

- IBM 카드  
종이에 구멍을 뚫어 정보를 저장하는 형태로 가장 초기의 ROM.  
순차적 메모리로 일정 순서대로만 데이터를 읽을 수 있었다.  
데이터를 읽으려면 카드를 물리적으로 움직여야 했기 때문에 아주 느림  

- 마스크 프로그래머블(mask-programmable) ROM  
제조 공정에서 마스크에 미리 데이터를 기억시켜 놓아 아무 주소나 임의 대로 접근 할 수 있게 만든 ROM.

- PROM(Programmable ROM, 프로그래머블 읽기 전용 메모리)  
단 한 번만 ROM에 프로그램을 적어 넣을 수 있다.

- EPROM(erasable programmable ROM, 지울 수 있는 읽기 전용 메모리)  
패키지 위쪽에 수정 창이 있어서 특별한 자외선 빛으로 저장된 내용을 지울 수 있다.

- EEPROM(electrically EPROM, 전기로 지울 수 있는 읽기 전용 메모리)  
전기로 내부 테이터를 읽고 수정할 수 있다. 기술적으로는 RAM이다.  
데이터를 쓰고 지우는데 시간이 오래 걸리고 RAM보다 비싸므로 ROM을 대신하는 목적으로 사용

<br></br>

### 블록 장치 (p.156)
대형 저장장치(mass storage)인 디스크 드라이브(disk drive)를 소개한다.

자화된 판(platter)에 비트를 저장하고, 디스크가 돌면 디스크 헤드(disk head)가 정보를 가져온다.

가장 큰 특징으로는 비휘발성이고, 굉장히 많은 데이터 저장이 가능하다만, 속도가 느리다는 점이겠다.

디스크 구조로는 바이트 단위로 주소를 지정해 읽는 대신 블록 단위로 주소를 지정해 읽는다.

이 블록(block)은 역사적으로 섹터(sector)로 불렸다. -> 디스크에서 읽고 쓰기가 가능한 가장 작은 단위

모든 섹터에 같은 수의 비트가 들어있다. 그렇다면 원의 특성산 비트 밀도(bit density, bit/mm^2) 바깥쪽보다 안쪽이 더 높다. -> 바깥쪽 트랙에는 비트를 더 집어 넣을 수 있는 여유가 있어 낭비가 된다.

최신 디스크들은 위에 문제를 해결하기 위해 방사상 영역(radial zone)으로 구분해 해결했다.

디스크 성능 수치로는

탐색 시간(seek time) : 헤드를 한 트랙에서 다른 트랙으로 옮기는 시간
회전 지연 시간(rotational latency) : 원하는 데이터가 헤드 아래로 올 때까지 디스크가 도는데 걸리는 시간
디스크 드라이브 종류로는

```
하드 드라이브, hard drive : 위에서 말한 딱딱한 드라이브를 플로피 디스크가 출시되고 구분해서 불렀다.
플로피 디스크, floppy drive : 하드 디스크보다 더 저렴하고 (간단하게) 탈착이 가능한 드라이브
자기 드럼, magnetic drive : 회전하는 원통에 헤드가 줄지어 있는 기억 장치
자기 테이프, magnetic tape : 자화시킨 테이프를 감은 릴(reel)을 사용하는 또 다른 비휘발성 저장장치 (음향 카세트 테이프)
광학 디스크, optical disk : 자기 디스크와 비슷한, 데이터를 읽고 쓰기 위해 자성 대신 빛을 사용한다. (CD, DVD)
```
<br></br>

### 플래시 메모리와 SSD (p.159)
플래시 메모리, flash memory : EEPROM 유형의 한 매채이다. DRAM과 마찬가지로 버킷에 전자를 담지만, 크고 견고해서 전자가 새지 않는다. 하지만 여러 번 읽고 쓰면 뚜껑이 여닫아지고, 경처비 닳아서 끊어진다.
EEPROM 보다 빨리 지울 수 있고 더 저렴하게 만들어진다. RAM처럼 원하는 위치를 마음대로 읽을 수 있는 임의 접근(random access)이고 쓸 때 블록 접근(block access)이다.

고체 상태 드라이브, solid-state drive, SSD : 디스크 드라이브는 점차 SSD로 교체되고 있는 추세다. 디스크 드라이브 모양의 패키지에 넣은 플래시 메모리와 같다. 플래시 메모리는 점차 낡기 때문에 여러 블록의 쓴 횟수를 기억해 모든 블록이 가능하면 똑같은 수준으로 낡도록 조정(wear leveling)하는 프로세서가 들어 있다.
<br></br>

## 오류 감지와 정정 (p.159)
오류와 정정의 개념을 시작으로 여러 기법들을 소개한다.

### 패리티 (parity)
1비트만 데이터가 잘못된 경우를 감지할 수 있다. 데이터에서 1로 설정된 비트의 개수를 세고, 그 개수가 짝수인지 홀수인지 나타내는 1비트를 데이터에 덧붙이는 방법이다. XOR를 활용해 패리티 비트를 만들 수 있다.

- 짝수 패리티, even parity : 모든 비트를 서로 XOR 한 값을 사용
- 홀수 패리티, odd parity : XOR 한 값의 보수를 사용
(p.161)에 홀수, 짝수 설명과 스키매틱 기호

### 해밍 코드 (hamming code) 
리처드 해밍이 발명, 더 많은 오류를 사용해 더 많은 오류를 감지하고, 횟수가 작다면 오류가 일어난 부분을 바로 수정한다. 이러한 회로를 내장한 오류 검사와 정정(ECC, error checking and correction)메모리 칩도 있다.

### 체크섬 (checksum)
데이터의 각 지점을 n 비트값으로 더하고, n 비트를 넘어가는 값은 무시한다. 체크섬에 사용하는 값이 크면 클수록 위양성(false positive) 결과가 발생하기는 더 어려워진다. (위양성 설명 p.161)

### 순환 중복 검사 (CRC, cyclic redundancy check)
수학적으로 체크섬보다 더 나은 대체제이고, 해시 코드 또한 또 다른 더 나은 대체재이다.

