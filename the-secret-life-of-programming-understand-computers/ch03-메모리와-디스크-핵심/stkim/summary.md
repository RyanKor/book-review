3장에서는 `순차 논리(sequential logic)`를 배운다. 2장에서 다룬 조합 논리는 입력의 현재 상태만을 다루지만, 순차 논리는 입력의 현재 상태와 과거 상태를 함께 고려한다.

<br/>

# 시간 표현과 상태 기억

시간을 측정하기 위해서는 `주기`라는 것을 이용한다. 지구의 한 바퀴 자전을 하루라고 규정하는 것 또는 진자가 오가는 시간을 기준으로 삼는 괘종시계와 같이 주기라는 개념이 시간에 있어 매우 중요하다. 컴퓨터에서도 마찬가지로 `주기적인` 전기 신호가 필요하다. 주기적인 전기 신호를 전송하기 위해서는 `발진자`를 이용하고, 발진자는 `클록`을 통해 회로의 페이스를 결정한다.

<br/>

### 발진자(oscillator)

먼저 `발진(oscillation)`이란, 주기적이고 반복적인 진동을 말한다. 즉, 정해진 공간에서 같은 운동을 반복하는 주기(periodicity) 운동이다.

<div align="center">

![](https://velog.velcdn.com/images%2Fyun2021%2Fpost%2Ff755cb8b-367b-4813-90d4-e99196b5f7d0%2F%EB%B0%9C%EC%8B%A0%EC%9E%90%20%EA%B7%B8%EB%A6%BC.png)

</div>

인버터의 출력을 입력에 연결하는 `피드백 연결`로 발진자가 만들어진다. 인버터의 출력은 다시 인버터의 입력으로 들어가며, 이 입력은 다시 출력에 반영된다. 2장에서 인버터는, 논리 회로에서 입력과 반대 부호의 출력을 만드는 연산 요소 또는 회로라고 배웠다. 즉, 0이 입력되면 인버터로 인해 1로 뒤집히고, 뒤집힌 1이 입력되면 인버터로 다시 0이 되는 구조이다. 이로 인해 출력이 0과 1을 반복하고, 이를 0과 1 사이를 진동한다고 표현한다. 또한, 진동하는 속도는 전파 지연과 온도에 따라 결정되기 때문에 안정적인 주파수로 진동하는 발진자가 있다면 시간을 더 정확하게 측정할 수 있다.

크리스탈을 활용해서 적은 비용으로 더 정확한 발진자를 만들 수 있다. 전극을 크리스탈에 연결하고 압축하면 크리스탈이 전기를 만들어낸다. 그리고 전극에 전기를 가하면 크리스탈이 구부러진다고 한다. 이런 현상을 `피에조 전기(piezoelectric), 압전 효과`라고 한다. 크리스탈 발전자는 단극쌍투 스위치로 전기를 가해 다시 전기를 얻는다. 이때 전기를 다시 만들어내는 시간은 예측이 가능하며 매우 정확하다고 한다.

<br></br>

### 클록(clock)

위의 발진자로 시간을 정확하게 측정할 수 있다고 했다. 하지만 개발자의 입장(고수준)이 아닌 컴퓨터 내부 부품 관점(저수준)에서도 시간은 중요하다.
`클록(동작 주파수)`이란, 신호를 셀 수 있게 해주는 신호이자 CPU의 속도를 나타내는 단위이다. 1초 동안 파장이 한 번 움직이는 시간을 의미하며, 이 시간 동안 처리하는 데이터 양에 따라 CPU의 속도가 달라진다. 발진자는 컴퓨터에 이 클록을 제공한다. 클록은 회로의 pace를 결정하고, 회로의 최대 클록 속도나 가장 빠른 템포는 회로의 전파 지연 시간에 의해 결정된다.

<br></br>

### 래치(latch)

0과 1을 다루는 정보 1비트를 기억하는 방법 중 하나로 래치를 사용하는 방법이 있다. 래치는 비트를 임시로 저장할 수 있는 소자 중 하나다. 2개의 게이트로 구성되며, 게이트 하나의 출력이 다른 게이트의 입력으로 다시 연결되는 피드백 연결 형태를 갖고 있다.
단순 OR 게이트 래치는 출력이 1이 되는 순간부터는 다시 0으로 되돌릴 방법이 없다. 따라서 되먹임을 끊고 회로를 재설정(reset)하는 장치가 필요하다.

<div align="center">

![](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcXL6YW%2Fbtq9R4AAfa9%2FK7PvZrzysKNgKjxAFqvpF1%2Fimg.png)

</div>

위 그림은 `AND-OR 게이트 래치`를 나타낸다. 인버터의 출력을 reset 글자 위에 선을 표시한 `리셋 바`로 표현한다. 선을 그은 리셋 바는 인버터의 출력으로 반전을 뜻한다. 0일 때 참이고, 1일 때 거짓인 것이다. 이를 `액티브 하이(Active High)`와 `액티브 로우(Active Low)`로 표현하기도 하는데, 참일 경우 액티브 하이에서는 1로 나타내지만 액티브 로우에서는 0으로 나타낸다.
리셋 바가 로우라면 리셋은 하이이므로, OR 게이트의 출력은 다시 입력으로 되먹임된다. 하지만 하이라면 리셋은 로우이므로 되먹임이 멈추면서 출력은 다시 0이 된다.

<br/>

<div align="center">

![](https://mblogthumb-phinf.pstatic.net/MjAxNzA5MTFfMjE4/MDAxNTA1MDkzMzQ2NjAz.I4AimFZA07Tbz6oEPopK9yLCYsM6JaUMl65uB3m4RUwg.vYTiP4uriGi4yEHSMvAJQUXiRp8up4PbIfSq9vrL_PMg.JPEG.hhs4040/2.jpg?type=w2)

</div>

위 그림은 `S-R 래치`이다. S-R은 Set-Reset을 뜻하며, 액티브 로우 입력을 받고 한쪽은 액티브 하이, 다른 한쪽은 액티브 로우를 출력하는 보수(complementary) 출력을 제공한다. AND-OR 게이트 래치와 비교해 설계가 대칭적이며, 이는 set과 reset 신호의 지연 시간이 거의 비슷하다는 뜻이다.

<br></br>

### 게이트가 있는 래치

특정 타이밍에 S-R 래치를 동작시키기 위한 기능을 추가할 수 있다. 이를 위해 `OR 게이트`와 S-R 래치의 동작을 On/Off 하기 위해 `gate 입력`을 사용한다.

<div align="center">

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FuuYbe%2Fbtq99mlutNm%2FMC2LyGI0zmuKohWpVIrmf1%2Fimg.png)

</div>

게이트 바의 입력이 1이면 출력은 항상 1이다. 따라서 Set과 Reset 값에 상관없이 NAND 게이트에는 1이 입력된다. 앞에 S-R 래치에서도 확인한 것처럼 셋 바와 리셋 바의 입력이 모두 1이면 이전 값을 보존한다.

<br/>

<div align="center">

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb1fbL5%2Fbtrac8nERRJ%2FRKJzXUiIBXajbKoTa4Q9F1%2Fimg.png)

</div>

Set과 Reset 대신 하나의 입력으로 구현한 것이 위 그림의 `gate가 있는 D 래치`이다. Set과 Reset의 입력을 D 하나로 묶은 것이다. 따라서 D만 입력하면 Set과 Reset으로 각각의 OR 게이트에 입력이 된다. 한쪽은 NOT 게이트를 거치기 때문에 Set과 Reset은 서로 보수 관계의 입력만 가능하다는 특징이 있다.

<div align="center">

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbWiFJO%2FbtrackWqLm6%2F9I631Bhkbo0ZrJW0Zdk8lK%2Fimg.png)

</div>

S-R 래치보다 효율적이다. 입력은 gate와 D로 간소화되며, set과 reset의 입력이 1로 동일한 경우를 방지할 수 있다. 하지만 게이트바가 로우-참인 상태에서는 D의 변화가 그대로 출력에 나타난다는 단점이 있다.

<br></br>

### 참고 자료

- [[정보통신기술용어해설] Oscillation, Oscillator, Vibrator 발진, 발진기, 진동자](http://www.ktword.co.kr/test/view/view.php?m_temp1=2102)
- [[인프라 용어 알아보기] 제 1탄: CPU – 제조공정, 클럭, 코어, 스레드, 캐시 메모리](https://library.gabia.com/contents/infrahosting/1227/)
- [[순차회로] 래치](https://soojong.tistory.com/entry/%EC%9E%91%EC%84%B1%EC%A4%91%EC%88%9C%EC%B0%A8%ED%9A%8C%EB%A1%9C-%EB%9E%98%EC%B9%98)
- [[논리회로] S-R 래치와 D 래치의 동작](https://blog.naver.com/tnalsdl326/220195772770)

### 플립플롭

<br/>

데이터 변경으로 인해 잘못된 결과가 생길 수 있는 가능성을 최소화하기 위해 가장 일반적으로 사용되는 방법은,  
논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 것이다.  
이 전이를 `edge`(에지)라고 부른다. 논리 수준 사이의 전이는(0에서 1, 1에서 0) 정말 순식간에 일어난다.  
`플립플롭`이란 "에지에 의해 데이터 변화가 촉발되는 래치"를 말한다.

<br/>

클록이 로우이거나 하이인 경우에는 D를 바꿔도 아무 일도 일어나지 않는다.
클록의 신호가 0에서 1로 바뀌는 시점 혹은 1에서 0으로 바뀌는 시점에 입력값(D)이 플립플롭에 저장된다.
플립플롭의 상태 변화 타이밍을 볼 때는 전파 지연외에도 `셋업 타임`과 `홀드 타임`도 고려해야 한다.

- 셋업 타임 : 클록 에지가 발생하기 전에 신호가 얼마나 안정적으로 유지되야 하는지를 나타내는 시간
- 홀드 타임 : 클록 에지가 발생한 이후에 신호가 얼마나 안정적으로 유지되야 하는지를 나타내는 시간

클록 에지 근처의 설정과 유지 시간을 제외한 나머지 시간에는 입력값이 무엇이든 출력값에 영향을 주지 않는다는 걸 알 수 있다.

<br/>

### 카운터

<br/>

플립플롭을 응용한 회로 중에 1,2,3 순서대로 수를 세는 카운터가 있다.
각 플립플롭의 D 입력이 자기 자신의 notQ 출력과 연결되어 있기 때문에,  
각 플립플롭은 자신의 클록 신호가 0에서 1로 전이될 때마다 상태가 바뀐다.

각 비트의 상태가 다른 비트의 상태 변화에 약간의 `시차`를 두고 바뀌기 때문에 이 회로를 `비동기 카운터`라고 부르기도 한다.  
상태 변화가 시차를 두고 일어나기 때문에 출력값이 나오는 시점을 예측하기 어려워, 원하는대로 동작하지 않는 경우가 생긴다.

이러한 타이밍 문제를 해결하기 위해 나온 것이 `동기적 카운터`이다.  
리플 카운터와 달리 동기적 카운터는 상태 변경이 `동시`에 일어난다.  
모든 플립플롭에 같은 클록을 병렬로 연결한다는 것을 의미한다 !!

<br/>

### 레지스터

<br/>

D 플립플롭을 사용하면 더 많은 정보를 쉽게 기억할 수 있다.  
값을 기억하기 위해 D 플립플롭을 사용하는 것은 아주 흔한 일이다.  
`레지스터`는 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것이다.  
가산기 출력을 클록을 사용해 레지스터에 넣고 나면, 가산기 입력을 바꿔도 결과는 바뀌지 않는다.

<br/>

# 메모리 조직과 주소 지정

- 주소(Address)  
  많은 레지스터들을 이용해 데이터를 저장할 때 그 레지스터들에 번호를 부여한다. 이 번호를 `주소`라고 한다.  
  `디코더`의 출력을 레지스터의 입력을 활성화 하기위해 사용한다.  
  지정한 주소에 해당하는 레지스터의 출력을 선택할때 `실렉터`를 이용한다.
- 트라이스테이트(tri-state) 출력  
  시스템에서 여러 메모리 컴포넌트의 출력을 한 출력으로 연결하는 경우 필요한 기본 요소
- 버스(bus)  
  데이터를 대량으로 이동 시킬 수 있는 교통 수단  
  a메모리 칩에는 `주소 버스(address bus)`, `데이터 버스(data bus)`가 있다.

메모리칩은 격자로 관리되고 메모리칩 내부를 행(row)과 열(column)으로 두 덩어리로 나누어 이 둘을 조합해 주소를 지정한다.  
행과 열 주소를 `멀티플렉싱(multiplexing)`을 통해 주소 라인 수를 절약한다.  
예를 들어 행 주소를 먼저 지정하고 열 주소만 변화시키는 방식으로 처리 속도를 높힐 수 있다.

### 임의 접근 메모리(random access memory, RAM)

- 휘발성(volatile) 메모리: 전원을 끄면 데이터가 사라짐
  - 정적(static) RAM, SRAM  
    각 비트 당 트랜지스터가 6개 들어간다.  
    비싸지만 아주 빠르고 트랜지스터가 차지하는 공간 때문에 대용량 비트를 저장하기에는 부적합하다.
  - 동적(dynamic) RAM, DRAM  
    커패시터(capacitor)라는 아주 작은 버킷에 전자를 담고 트랜지스터 1개만을 사용해 뚜껑을 덮는다.  
    집적도가 매우 높아 대용량 메모리칩에 사용된다.  
    버킷에 누수되는 문제가 있어 메모리를 중간에 갱신해주어야 한다.
- 비휘발성(non-volatile) 메모리: 전원을 꺼도 데이터가 사라지지 않음
  - 코어(core) 메모리  
    토러스 모양 쇳조각(자기 세라믹 링)인 코어에 자기장을 이용해 데이터를 저장한다.  
    이 코어에 전류를 흘려 자화시켜 1개의 비트를 저장한다.  
    격자에 코어가 배열된 형태로 코어는 외부의 전자기 간섭에 저항력이 매우 크다.

### 읽기 전용 메모리(read-only memory, ROM)

한 번만 쓸 수 있고 그 후는 읽기만 가능한 메모리

- IBM 카드  
  종이에 구멍을 뚫어 정보를 저장하는 형태로 가장 초기의 ROM.  
  순차적 메모리로 일정 순서대로만 데이터를 읽을 수 있었다.  
  데이터를 읽으려면 카드를 물리적으로 움직여야 했기 때문에 아주 느림  
  ![ibm카드](https://user-images.githubusercontent.com/91672778/169228303-f2ca1c2d-1a1f-4f85-9486-75e90bd67bfd.jpeg)

- 마스크 프로그래머블(mask-programmable) ROM  
  제조 공정에서 마스크에 미리 데이터를 기억시켜 놓아 아무 주소나 임의 대로 접근 할 수 있게 만든 ROM.
- PROM(Programmable ROM, 프로그래머블 읽기 전용 메모리)  
  단 한 번만 ROM에 프로그램을 적어 넣을 수 있다.
- EPROM(erasable programmable ROM, 지울 수 있는 읽기 전용 메모리)  
  패키지 위쪽에 수정 창이 있어서 특별한 자외선 빛으로 저장된 내용을 지울 수 있다.
- EEPROM(electrically EPROM, 전기로 지울 수 있는 읽기 전용 메모리)  
  전기로 내부 테이터를 읽고 수정할 수 있다. 기술적으로는 RAM이다.  
  데이터를 쓰고 지우는데 시간이 오래 걸리고 RAM보다 비싸므로 ROM을 대신하는 목적으로 사용

# 블록장치

### 블록장치란?

디스크 또는 테이프 장치 따위와 같이 한 순간에 하나의 블록을 단위로 하여 입출력 작업을 수행하는 장치.

<br>

### 대표적인 저장장치: 디스크 드라이브

- '접시'역할을 하는 `플래터`에 비트를 저장한다.
- '손' 역할을 하는 `디스크 헤드`가 데이터를 읽어들인다.
- 기록 밀도와 속도를 맞바꿔, 다른 유형의 메모리에 비해 속도가 느리다.
- 하지만 DRAM 등과 달리 주소나 데이터 연결을 위한 공간이 필요 없다.
- 먼지가 들어가거나 표면이 오염되면 문제가 생기기 때문에 일반인은 절대 열지 않는 것을 추천
  => 먼지가 조금 들어가도 불량 섹터가 생기고 점점 늘어난다. 그리고 전문 장비가 있지 않는 이상 해체는 해도 재조립이 어렵다.

  <img width="300" alt="image" src="https://user-images.githubusercontent.com/91880235/169628183-fa507aaf-21b3-4c41-b7bc-d20d800bdaa2.png">

<br>

### 블록(섹터)이란?

- `섹터`는 디스크에서 읽고 쓰기가 가능한 가장 작은 단위다.
- 역사적으로 섹터당 512바이트를 저장했으나 최근에는 4,096(4KB) 바이트를 저장(`어드밴스드 포맷`)한다.
  이 말은 즉슨, 남는 부분은 버려지고, 한 바이트를 바꾸고 싶어도 한 블록을 전체 다시 써야한다는 뜻!

  => 이는 디스크 할당 크기와 실제 크기가 차이나는 이유기도 함
  <img width="300" alt="image" src="https://user-images.githubusercontent.com/91880235/169628292-5cf69d64-7539-444d-9055-57385573ef4e.png">

- 비트 밀도(bit/mm^2)는 각 원판의 바깥쪽보다 안쪽이 더 높다.
- 이 문제를 `방사상 영역(radial zone)`으로 구분해 해결하여 이 방식에서는 바깥쪽에 더 많은 섹터가 들어간다.
- 디스크 드라이브 성능을 표현하기 위한 수치

  1. 탐색 시간(Seek time)

     헤드와 플래터가 데이터를 읽고 쓰려는 트랙(실린더)에 정확히 정렬하는데까지 걸리는 시간(보통 20ms)

  2. 회전 지연 시간(rotational latency)

     헤드를 데이터가 위치하는 트랙으로 이동시킨 순가부터 원하는 섹터에 헤드가 다다를 때까지 소요되는 시간을 의미(보통 3200rpm)

     - rpm = 디스크의 분당 회전수

  3. 전송 시간(transfer time)

     헤드가 찾은 데이터를 실제로 디스크로부터 사용자의 버퍼로 보내지는데 소요되는 시간(1byte/0.1ms)

- 디스크 드라이브를 하드 드라이브라고 불리게 된 이유는
  잘 구부러지는 재질의 플로피 디스크와 구분하기 위함이었음

<br>

### 그 외 ETc..

- 자기 드럼: 이름 그대로 회전하는 원통에 헤드가 줄지어 있는 기억 장치(드럼통을 연상)
- 자기 테이프: 자화시킨 테이프를 감은 릴을 사용하는 또 다른 비휘발성 저장장치 기술
- 광학디스크: 데이터를 읽고 쓰기 위해 자성 대신 빛을 사용함. CD나 DVD가 광학 디스크에 속함(대량생산에 적합함!)

<br>

### 참고

- [하드디스크 구조와 원리](https://imsosimin.com/notice/4)
- [하드디스크 - 나무위키](https://namu.wiki/w/%ED%95%98%EB%93%9C%20%EB%94%94%EC%8A%A4%ED%81%AC%20%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C)
- [운영체제 파일시스템에서 접근 시간, 디스크 스케줄링을 위한 알고리즘, I/O 시스템이란?](https://vmilsh.tistory.com/391)
- [하드디스크드라이브에 대해서...](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=thdr1603&logNo=220681689620)

# 플래시 메모리와 SSD

### 플래시 메모리

플래시 메모리는 가장 최근 나타난 EEPROM(Electrically Erasable Prommable ROM) 유형의 매체다. 일본의 도시바에서 발명하고 세계 최초로 상용화하였다.

음악 플레이어나 디지털 카메라 등의 응용에 적합하다.

- DRAM과 마찬가지로 버킷에 전자를 담는 방식으로 작동
- DRAM보다 더 크고 잘 만들어져 있어서 전자가 새지 않는다.
- EEPROM보다 더 빨리 지울 수 있고 더 저렴하게 만들 수 있음
- RAM처럼 원하는 위치를 마음대로 읽을 수 있다.
- 플래시 메모리의 특성상 읽을 때는 임의 접근 장치이고, 쓸 때는 블록 접근 장치처럼 작동한다.
- 플래시 메모리는 비휘발성으로, 작고 가벼우면서도, 자기 매체나 광학 매체에 비해 기계적인 충격에도 강하고, 직사광선, 고온, 습기에도 강하다.
- USB메모리, SD카드, 그리고 하드디스크와 같은 SSD 등에 널리 사용된다.

<br>

### 플래시 메모리의 종류

플래시 메모리는 `NOR`, `NAND`, `NINOR`, `AND의` 네 가지 형식으로 분류된다.
`NOR` 플래시와 `NAND` 플래시가 가장 많이 사용되며, 현재 `NAND` 플래시가 시장 점유율이 가장 높다.

[NOR VS NAND 비교]

- NOR
  - 셀을 병렬구조로 연결
  - byte 단위 읽기 가능
  - 읽기 성능은 우수하나 쓰기와 지우기가 느림
  - 지우기 횟수에 제한
  - 면적이 넓고 집적도 낮음
- NAND
  - 셀을 직렬 구조로 연결
  - 높은 집적도
  - 영역 단위의 읽기 및 쓰기
  - 읽기 성능 느림 쓰기 성능 우수

<img width="427" alt="image" src="https://user-images.githubusercontent.com/91880235/169628670-c1f147fc-aaf7-46d3-8c27-5a58ff01bcc6.png">

<br>

### SSD

- 디스크 드라이브는 점차 SSD로 널리 알려진 고체 상태 드라이브(solid-state drive)로 교체되고 있다.
- SSD는 디스크 드라이브 모양의 패키지에 넣은 플래시 메모리와 같다.
- SSD의 비트당 가격이 하드디스크보다 비싸지만 SSD 가격도 저렴해지는 추세
- 플래시 메모리는 점차 낡기 때문에 SSD에는 여러 블록의 쓴 횟수를 기억해서 모든 블록이 가능하면 똑같은 수준으로 낡도록 조정하는 프로세서가 들어있다.

  - wear leveling: 전체적인 셀에 골고루 데이터를 저장해 데드셀(dead cell)을 최대한 방지하는 기술

  <img width="600" alt="image" src="https://user-images.githubusercontent.com/91880235/169628830-bcbdb5a4-584b-4988-9808-18ea83489596.png">

### 참고

- [플래시 메모리 - 나무위키](https://namu.wiki/w/%ED%94%8C%EB%9E%98%EC%8B%9C%20%EB%A9%94%EB%AA%A8%EB%A6%AC)
- [SSD - 나무위키](https://namu.wiki/w/SSD)
- [웨어 레벨링이란?](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=dkdlelrktlfj&logNo=220347768909)
- [개발자를 위한 SSD (Coding for SSD) – Part 2 : SSD의 아키텍처와 벤치마킹](https://tech.kakao.com/2016/07/14/coding-for-ssd-part-2/)

# 오류 감지와 정정

한 줄기의 우주 방사선이 언제 메모리에 닿아서 비트가 잘못될 지 알 수 없다. 이럴 때 잘못된 부분을 즉시 복구할 수 있다면 좋을 것이다. 컴퓨터는 데이터에 오류가 생겼을 때 어떻게 감지할까?

<br />

### 패리티

- 데이터에서 `1로 설정된 비트의 개수`가 `짝수`인지 `홀수`인지 나타내는 1비트를 데이터에 덧붙인다.
- 모든 비트의 XOR을 취하면 위와 같은 비트를 만들 수 있다.
- 단 1비트만 데이터가 잘못된 경우도 감지할 수 있다.
- 그러나 오류가 짝수 번 발생하면 오류가 발생하지 않은 경우와 구분이 불가능하다.
- `끊임없이 변화하는 데이터`를 처리할 때 유용하다.

<br />

- **짝수 패리티**
  모든 비트를 서로 `XOR`한 값
- **홀수 패리티**
  모든 비트를 서로 `XOR`한 값의 보수를 사용
  <br />

### 해밍 코드 (Hamming code)

- 패리티보다 더 많은 비트를 사용해 더 많은 오류를 감지할 수 있다.
- 오류 횟수가 적으면 오류가 일어난 부분을 바로 수정할 수 있다.
- 이 회로를 내장한 `오류 검사와 정정 메모리칩 (ECC, error checking and correction)`이라는 것이 있다.
  <br />

### 체크섬 (ckechsum)

- 데이터의 각 지점을 n 비트값으로 더하고, n비트를 넘어가는 값은 무시한다.
- 체크섬에서 사용하는 값이 클수록 `위양성 결과 (데이터가 잘못되었음)`가 발생하기는 더 어렵다.
- 컴퓨터 프로그램과 같이 정적인 데이터 블록을 검증한다.

<br />

### 순환 중복 검사 (CRC, cyclic redundancy check)

- 수학적으로 체크섬보다 더 낫다.
- 데이터의 고유성을 충분히 드러낼 수 있는 방식으로 `검증 숫자`를 계산해, 데이터가 약간이라도 바뀌면 검증 숫자가 일치하지 않게 하는 것이다.

# 하드웨어와 소프트웨어 비교

논리 회로를 통해 컴퓨터의 하드웨어를 만들 수 있다. 우리는 프로그래밍을 통해. 프로그램 코드에 논리가 들어가며, 명령어의 집합으로 이를 사용할 수 있다. 그러면 논리를 하드웨어로 만드는 것과 소프트웨어로 만드는 것 사이에 어떤 차이가 있을까?

**펌웨어 (firmware)**
원래 `ROM에 담긴 소프트웨어`를 가리키는 용어였지만, 요즘에는 `플래시 메모리상`에 존재하거나, `RAM상`에도 존재한다. 따라서 펌웨인 소프트웨어와 펌웨어가 아닌 소프트웨어 사이의 차이가 아주 적어졌다.

큰 마일라 필름 위에 색이 다른 마스킹 테이프를 붙이며 칩을 설계하던 시절이 있었다. 그러나 1979년 [Introduction to VLSI Systems] 라는 책이 나오며, `전자 설계 자동화`가 시작되었다. 이후 칩 설계는 소프트웨어 개발이 되었다.

대부분 프로그래머들에게는 사용해야 할 하드웨어가 주어졌지만, 나중에 하드웨어와 소프트웨어를 함께 설계해야할 수도 있다.

초번에 모든 칩의 설계는 설계자가 만들어놓은 완전한 커스텀이었다. 그 후 `게이트 배열(gate array)`에서는 금속 계층만 커스텀화할 수 있다. 그리고 `PROM`에 해당하는 직접 프로그래밍 할 수 있는 칩으로 변화했고, 지우고 다시 프로그래밍 할 수 있는 `EEPROM`에 해당하는 칩도 존재한다.

**현대적 FPGA(field-programmable gate array)**
플래시 메모리에 해당하는 논리칩이다. 이를 이용해 소프트웨어 로직을 지우고, 다시 프로그래밍할 수 있다. 게다가 저렵하고, 기능이 다양하다.
ex) ARM 프로세서 코어가 여러 개 들어있는 큰 FPG 등
