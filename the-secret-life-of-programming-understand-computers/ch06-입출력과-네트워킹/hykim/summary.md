# 저수준 I/O (1)

## I/O 포트

가장 단순한 I/O는 CPU가 읽고 쓸 수 있는 비트에 물건을 연결한 형태의 I/O이다.

### PORTB

포트 B는 세 가지 레지스터에 의해 제어된다.
![AVR PORTB 레지스터](https://media.discordapp.net/attachments/879215554379018243/987693143614976010/IMG_9658.jpg)

![AVR 포트 B의 구성](https://cdn.discordapp.com/attachments/879215554379018243/987695694976536616/unknown.png)

- **DDRB(데이터 방향 레지스터)**
  - PORTB에 대한 `데이터방향 레지스터`이다.
  - 각 핀을 입력으로 쓸지 출력으로 쓸지 결정
  - 레지스터의 비트에 `1`을 넣으면 그 비트 번호에 해당하는 포트 B 비트가 `출력`에 쓰인다.
  - `0`을 넣으면 `입력`에 쓰인다.
- **PORTB**
  - 어느 비트에 0이나 1을 넣으면 핀의 출력 전압이 0이나 1로 바뀐다.
- **PINB**
  - 핀의 값을 읽는다.
    ex) 6번, 0번 핀을 하이, 나머지를 로우로 한다. => 01000001(0x41)

![포트 B에 전구와 스위치를 연결한 모습](https://cdn.discordapp.com/attachments/879215554379018243/987695166636826634/unknown.png)

위는 포트 B에 전구와 스위치를 연결한 것이다. PB7은 전압을 0에서 1로 전환할 수 있고, PB0은 아무 전류도 흐르지 않는다. 전기는 PB0이 1일 때 LED를 통해 흐르고, LED를 빛나게 한다. 따라서 PORTB0 비트에 값을 넣으면 LED를 켜거나 끌 수 있다.

# 저수준 I/O (2)

## 버튼을 눌러라

다양한 장치에 버튼이나 스위치가 들어가고, 컴퓨터가 버튼이나 스위치의 값을 읽기는 쉽지가 않다. 컴퓨터가 어떻게 이 값을 읽는지 알아보자

#### IRQ(인터럽트 요청)

<details>
<summary>책 내용 요약</summary>
<div>

![간단한 푸시 버튼 회로](https://cdn.discordapp.com/attachments/879215554379018243/987698439154458665/unknown.png)

R = 풀업 저항(pull-up)
**버튼이 눌리지 않은 경우** - 저항이 인터럽트 요청 핀에 연결된 선의 전압을 공급 전압까지 올려 논리 1을 만들어준다. - 버튼이 눌리면 저항은 전류를 제한하면서 IRQ에 논리 0을 공급한다.

 <br />

![버튼 바운스](https://media.discordapp.net/attachments/879215554379018243/987693143086493706/IMG_9661.jpg)

그럼 버튼을 눌렀다 떼면 IRQ에 입력되는 신호가 6-5의 왼쪽 신호라고 생각할 수 있다.
그러나 실제로는 버튼의 금속 조각이 접점에 닿으면 잠깐 되팅겨지면서(바운스) 접점에서 떨어진다. 이런 인터럽트가 여러 번 발생할 수 있고, 이를 디바운스 (튕김을 없앰) 해야한다.

![버튼 디바운스 타이머](https://cdn.discordapp.com/attachments/879215554379018243/987698658814357654/unknown.png)

따라서 인터럽트 핸들러에 타이머를 설정하고, 이 시간이 지나면 버튼 상태를 감지하는 방법이 있다. 그러나 이런 방법도 기계 부품이 낡음에 따라 버튼 바운스 시간이 달라져 타이머 값을 정하기 어렵다.

이런 인터럽트를 만들어내는 일종의 타이머는 대부분의 시스템에 존재한다. 이를 통해 버튼 디바운싱을 해결한다.

</div>
</details>
<br />

`인터럽트 요청`은 컴퓨터에서 CPU를 `인터럽트` 하라는 요청에 사용된다.

`인터럽트`: CPU가 프로그램을 실행할 때, 입출력 하드웨어 등 장치에 `예외 상황`이 발생하여 처리가 필요한 경우, CPU에게 알려 처리할 수 있도록 하는 것

이런 인터럽트 요청은 키보드 누르기, 마우스 이동, 프린터 작업 등과 같은 작업에 필요하다. 장치가 일시적으로 프로세서를 중지하라는 요청이 이루어지면, 컴퓨터는 장치에 자체 작업을 실행할 수 있는 시간을 줄 수 있다.
ex) 키보드의 키를 누를 때마다 인터럽트 처리기가 현재 진행중인 작업을 중지해야만 키보드 입력을 처리할 수 있음을 프로세서에게 알린다.

인터럽트 요청은 `채널`이라는 고유 회선을 통해 이루어지며, `IRQ 번호`라고도 한다.
0~15번까지 구성되어 있고, 역할이 미리 할당되어 있는 것과 예비인 것도 있다.

| 채널 | 역할                                                              |
| ---- | ----------------------------------------------------------------- |
| 0    | IRQ 타이머                                                        |
| 1    | 키보드                                                            |
| 2    | IRQ 캐스 케이드 공유                                              |
| 3    | 시리얼포트 2, COM2, COM4 ( 모뎀 / 마우스)                         |
| 4    | 시리얼포트 1, COM1, COM3 ( 모뎀 / 마우스)                         |
| 5    | LPT2 병렬포트 혹은                                                |
| 6    | FDD 컨트롤러                                                      |
| 7    | LPT1 병열 포트 등 혹은 사운드카드                                 |
| 8    | RTC( Real Time Clock)                                             |
| 9    | 예비, 주로 미디 카드(MPU401)에서 사용 , SOUND ,VGA . USB, MPEG II |
| 10   | 예비 , SOUND ,VGA . USB,MPEG II,                                  |
| 11   | 예비, SCSI 아답터, SOUND ,VGA . USB,MPEG II                       |
| 12   | PS/2 마우스                                                       |
| 13   | 코프로세서 (수치처리보조연산자 )                                  |
| 14   | IDE 하드 컨트롤러 Primary                                         |
| 15   | IDE 하드 컨트롤러 Secondary                                       |

만약 두 개의 하드웨어가 인터럽트 요청을 위해 동일한 채널을 사용하면 `IRQ 충돌`이 발생하기도 한다.
Windows 초기에는 IRQ 오류가 자주 발생했지만, 최신 버전에서는 `플러그 앤 플레이`를 사용하여 충돌 문제가 거의 발생하지 않는다.

<br />

#### 유한 임펄스 응답 (FIR, finite impulse response)

<details>
<summary>책 내용 요약</summary>
<div>
 
![FIR 필터 버튼 디바운서](https://mblogthumb-phinf.pstatic.net/MjAxNzEyMDVfMTYg/MDAxNTEyNDgzMzkyNTMy.UJGkD0YZ61FgBsxsZX6wwPygY-ptCMGFCPTz0aTivPQg.QBnTPIsy78oIVJzsyzhFXURq_rRvztq0uWK15sJ-SEkg.PNG.pro_000/%EC%BA%A1%EC%B2%98.PNG?type=w2)
 
FIR은 큐(queue)로, 타이머 틱이 발생할 때마다 가장 오래된 값을 버리고, 새 값을 넣으면서 각 값을 하나씩 시프트 한다.  
배열 원소들을 OR 해서 상태를 만들어낸다.
원소가 2개(current, previous)있는 큐의 current 입력으로 넣는다.
current에 값을 넣기 직전 current 값은 previous로 옮긴다.
current값과 previous값을 XOR 하면 어떤 버튼이 상태가 바뀌었는지 알 수 있다.
</div>
</details>
<br />

- FIR은 DSP (디지털 신호 처리)에서 원하는 특정 주파수를 거르거나 통과시키는 역할을 한다.
- 입력 신호의 일정한 값들만을 가지고 filtering을 수행한다.
- 회귀 성분을 갖지 않아, 동일 특성을 구현할 때 IIR 보다 구현 비용이 많이 든다.
- 위상 변이가 중요한 경우, 반드시 FIR 필터를 사용해야 한다.
- 아날로그 필터 응답을 시뮬레이션 할 수 없다.

#### 무한 임펄스 응답 (IIR, Infinite impulse response)

- 디지털 필터의 한 종류로 입력 신호 값과 출력 신호 값이 재귀적으로 적용된다.
- 임펄스의 응답은 무한한 길이를 갖는다.
- FIR보다 구현 비용이 적지만, 비선형성이므로 입력 파형과 출력 파형이 유사하지 않다.

---

[참고] <br />
[인터럽트 위키백과](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8) <br />
[인터럽트 요청 위키백과](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8_%EC%9A%94%EC%B2%AD) <br />
[IRQ(인터럽트요청)란 무엇입니까?](https://ko.eyewated.com/irq-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EC%9A%94%EC%B2%AD-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9E%85%EB%8B%88%EA%B9%8C/) <br />
[IRQ (Interrupt Request)가 무엇입니까?](https://www.sony.co.kr/electronics/support/articles/S500082584) <br />
[IIR 필터 & FIR 필터](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=futuremain&logNo=221299403374) <br />


# 빛이 있으라

- `7세그먼트 디스플레이`는 가장흔한 유형의 디스플레이 표시 장치다. (시계, 전자레인지 등에 사용)
- 7개의 LED가 숫자 8 형태로 나열되어 있고, 소수점을 표현하는 LED(DP, Decimal Point)가 하나 더 붙어있다.
- 8개의 LED를 처리하려면 `16가지 전기적 접점(핀)`이 필요하지만 보통 LED마다 핀을 1개씩 연결하고, 공통된 LED를 하나 연결하여 `9개`를 사용한다. 이것이 `공통 캐소드`다. 
<img width="500" alt="image" src="https://user-images.githubusercontent.com/91880235/174304395-1cd8ad82-8703-4904-a214-41ef858d789c.png">

<br>

- `공통 캐소드`: 공통핀을 캐소드(-)에 연결한 경우

- `공통 애노드`: 공통핀을 애노드(+)에 연결한 경우
<img width="500" alt="image" src="https://user-images.githubusercontent.com/91880235/174298904-41ef44c0-bb6e-43a3-a7d6-5c12f6bf9b54.png">

- 이 디스플레이를 작동 시키기 위해서는 `시각의 잔상효과를 이용한다.`
- 1/24초보다 짧은 간격으로 깜빡일 경우 빛이 켜져있는 걸로 인식 (예시) 프레임, 타이머 인터럽트 핸들러를 사용해 사용할 수 있음)
 
 
<br>

# 빛, 동작, 그리고 상호 연동

보통 디스플레이를 하나만 쓰는 경우는 드물기 때문에 여러 개의 세그먼트를 동작 시키려는 경우 `멀티플렉스`를 이용해야한다.

<img width="500" alt="image" src="https://user-images.githubusercontent.com/91880235/174314613-c79a2efa-f6b3-4207-89f7-d30e1426f976.png">

<img width="500" alt="image" src="https://user-images.githubusercontent.com/91880235/174306610-297ab537-5bba-4715-8e10-f0cbc443a8f7.png">

- 푸시버튼을 12개를 사용하기 위해 핀을 12개를 추가하지 않고 단지 3개(C0, C1, C2)만 추가하면 된다.
- A는 디스플레이에 공통적으로 연결
- B는 각각 디스플레이 연결에 해당하며, 번호의 가로줄과도 연결
- 디스플레이를 선택하면 C가 선택(로우)되면서 번호를 누를 수 있다.
- 이 때, 디스플레이(B)와 푸시 버튼(C)가 똑같은 신호에 선택되기에 `상태를 스캔하는 코드`를 `인터럽트 핸들러`에 함께 넣을 수 있다.
- 위 그림은 `오픈 콜렉터`거나 `오픈 드레인`일 수 있다. 오픈 컬렉터나 오픈 드레인이 아닐 때 그림처럼 동시에 각기 다른 줄에 있는 같은 열에 속한 버튼을 누르면 0, 1을 서로 연결하게 되어 부품이 손상될 수 있지만 보통 디스플레이 드라이버가 이를 해결해준다.

<br>

# 밝기 조절

밝기 조절은 디스플레이의 `듀티 사이클`을 조절함으로써 가능하다.

`듀티 사이클(duty cycle)`은 기계 제어 공정에서 많이 쓰이는 개념 중 하나로 신호의 한 주기(period)에서 신호가 켜져있는 시간의 비율을 백분율로 나타낸 수치

<img width="539" alt="image" src="https://user-images.githubusercontent.com/91880235/174309630-9fec183d-6a0a-4437-b222-ab5a97864b3b.png">

`왼쪽은 각 화면의 1/4의 밝기`,   `오른쪽은 각 화면의 1/8 밝기`


이것은 밝기의 작동 시간과 관련있다. 듀티 사이클이 1/2라고 하면 밝기는 절반정도로 보인다.

하지만 듀티 사이클과 사람이 인지하는 밝기 사이의 관계는 선형이 아닐 것이다.


<br>

# 그레이의 2n가지 그림자

- `그레이 코드(gray code)`는 이진법 부호의 일종으로, 연속된 수가 1개의 비트만 다른 특징을 지닌다. 
- 연산에는 쓰이진 않고 주로 `데이터 전송`, `입출력 장치`, `아날로그-디지털 간 변환`과 `주변장치`에 쓰인다.
- 순차적인 증감되는 값을 최대한 오류없이 이용하기 위해 사용한다.

<img width="400" alt="image" src="https://user-images.githubusercontent.com/91880235/174310720-22f5ef8f-0c22-4bfe-b396-4d6e7ae1a389.png">

<img width="400" alt="image" src="https://user-images.githubusercontent.com/91880235/174311371-24c74efe-fc2c-4d97-a9e0-dea891d6f3f3.png">

<img width="400" alt="image" src="https://user-images.githubusercontent.com/91880235/174311405-a0a4b412-9aaa-4e25-b3fd-bad78853e0d3.png">


<br>

# 참고
- [7세그먼트 표시 장치 - 위키백과](https://ko.wikipedia.org/wiki/7%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8_%ED%91%9C%EC%8B%9C_%EC%9E%A5%EC%B9%98)
- [7 Segment에 대해 알아보자.](https://dokkodai.tistory.com/89)
- [오픈 콜렉터와 오픈 드레인 회로](http://itsys.hansung.ac.kr/cgi-bin/kplus/board/table/my_lec/upload/Tnote09.pdf)
- [오픈 컬렉터, 오픈 드레인이란?](https://gdnn.tistory.com/281)
- [그레이 코드(Gray code)를 사용하는 이유?](https://raisonde.tistory.com/entry/%EA%B7%B8%EB%A0%88%EC%9D%B4-%EC%BD%94%EB%93%9CGray-code%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)


# 저수준 I/O

### 쿼드러처  
**쿼드러처 인코딩(quadature encoding)**  
  
그레이 코드의 변형으로 이전 위치와 현재 위치를 비교해 대상의 절대적인 위치는 알 수 없지만 상대적인 위치를 알 수 있는 장치  
회전축을 시계방향으로 돌리면 0132 순서로 코드가 발생하므로 이전 위치와 현재 위치로 4비트 숫자를 만들어 회전 방향을 알려준다.     
  
![쿼드러처](https://user-images.githubusercontent.com/91672778/174468825-5954dba0-dac6-4b34-8b3a-ceb8907bfa82.png)  
  
### 병렬 통신
  
여려 개의 병렬 채널 위로 동시의 여러 개의 신호를 보내는 것   
  
**스트로브 신호(strobe purse)**  
여러 연결 라인에서 비동기적으로 데이터를 주고 받을 때 데이터의 전송 시각을 알리는 제어 신호  
아래의 경우 스트로브 신호가 0인 경우만 비트들이 유효하다.  
  
![스트로브](https://user-images.githubusercontent.com/91672778/174469141-e41d7e60-01f4-41f4-ab65-712882a4443c.png)  
  
  
### 직렬 통신
  
연속적으로 통신 채널이나 컴퓨터 버스를 거쳐 한 번에 하나의 비트 단위로 데이터를 전송하는 과정  
거리가 멀어질 수록 병렬 통신에서 비해 비용 절감 가능  
SPI, I2C, TWI, 1-Wire 등의 인터페이스가 있다.  
  
**시프트 레지스터**  
- 송신하는 쪽 스트로브 신호가 비트를 한 위치씩 시프트시키며 밀려나가는 비트를 전송   
- 수신하는 쪽 클록이 비트를 한 위치 씩 비트를 시프트시키며 생긴 빈 자리에 받은 비트를 저장  
- 클록이 동기화 되어야 한다
  
![시프트레지스터](https://user-images.githubusercontent.com/91672778/174469498-0ade6bf8-16d7-4afc-87bb-df25392fe431.png)  
  
**마크-스페이스 신호**  
- 처음 시작 신호 이후 각자의 타이머에 따라 작동  
- 차이가 미미해 서로 잘 동기화  
- 처음엔 하이 상태였다가 처음 로우가 되는 `시작 비트(start bit)` 이후 8비트 데이터가 전송  
- 이후 문자의 끝에 하이 상태인 `정지 비트(stop bit)` 2개가 붙는다.
- 시간을 나눈 슬롯을 만들고 슬롯마다 다른 비트를 할당해 한 선에 멀티 플렉싱 -> `시간 분할 멀티플렉싱(time division multiplexing)`  
- 실렉터를 사용
  
![마크스페이스](https://user-images.githubusercontent.com/91672778/174469852-ae9b44da-49b2-438e-9325-f7567b6d4efd.png)  
  
**반이중 연결(helf-duplex) 통신**  
- 송신자와 수신자가 같은 선을 공유  
- 한 쪽이 데이터를 송신하는 경우 다른 쪽은 데이터 수신만 가능하다
  
**전이중(full-duplex) 통신**  
- 2개의 선으로 양 방향 통신이 가능
  
**UART,범용 비동기 송수신기(Universal Asynchronous Receiver-Transmitter)**  
- 병렬 데이터 형태를 직렬 방식으로 전환하여 데이터를 전송하게 해주는 하드웨어
- EIA RS-232, RS-422, RS-485와 같은 통신 표준과 함께 사용  


# 파동에 올라타라

<br/>

세상에는 다양한 파장이 있는데, 모든 파동은 `사인파`(sine wave)를 조합해 만들 수 있다.   

<br/>

<p>
<img width="500" src="https://user-images.githubusercontent.com/80025242/174449831-d89fcaf9-5b7d-4edb-9307-dc24abefb20b.png" alt="img-5"/>
</p>

<br/>

사인파의 높이 (0부터 파장의 가장 높은 지점까지) : `진폭`   
같은 방향으로 매초 0을(x축) 지나치는 횟수 : `주파수` -> 단위는 `헤르츠` === 초당 사이클   
같은 방향으로 0을 지나는 연속된 두 지점 사이의 거리 : `파장`   

```
파동의 속도 === 파장 x 주파수   
```

<br/>
<p>
<img width="300" src="https://user-images.githubusercontent.com/80025242/174450668-8131e161-953c-4b54-9fad-435d1cd73dd0.jpeg" alt="img-4"/>
</p>

<br/>

파동을 전달하는 파동을 `반송파(carrier)`(캐리어)라고 한다.   
우리가 전달하려는 신호를 바탕으로 `반송파`를 마크-스페이스 파형(waveform)처럼 변화시키는 `변조(modulation)` 과정이 필요하다.   
위 그림은 마크-스페이스에 의해 주파수가 shift 되기 때문에 `주파수 편이 변조(FSK)`(Frequency Shift Keying) 되는 과정을 보여준다.   

받는 쪽에서는 음향을 다시 마크-스페이스로 되돌려야 한다. -> `복조(demodulation)` 과정.   
`변조` 와 `복조` 를 수행하는 장치를 `모뎀(modem)`이라고 부른다.

<br/>
<p>
<img width="300" src="https://user-images.githubusercontent.com/80025242/174451467-e14fa2fa-dcfe-49d9-b7f8-8d0db82daad2.jpeg" alt="img-6"/>
</p>

<br/>
<br/>

# 범용 직렬 버스

<br/>

### USB (Universal Serial Bus) ?

<br/>

USB 는 사용하기 어렵고, 호환성이 떨어지는 커넥터를 사용하기 때문에   
데이터 전송보다는 장치 충전에 더 많이 사용된다.   

ex. PC에 프린터나 마우스와 같은, 주변기기를 접속하기 위한 장치

<br/>

#### [ USB 규격 등장 이전의 인터페이스 ]

<br/>
<p align="center">
<img width="300" src="https://user-images.githubusercontent.com/80025242/174447877-63601ae3-82ab-4628-a0f5-5078e97863af.jpeg" alt="img-1"/>
</p>
<p align="center">PS/2</p>
<p align="center">
<img width="300" src="https://user-images.githubusercontent.com/80025242/174448151-a70fee4d-4ecc-4450-971f-d883bb34c41d.png" alt="img-2"/>
</p>
<p align="center">RS-232</p>

<br/>

#### [ USB 규격 등장 이후의 인터페이스 ]

<br/>
<p align="center">
<img width="300" src="https://user-images.githubusercontent.com/80025242/174448676-a4f228ce-3c1f-4afb-8aaf-639006c6f4ed.jpeg" alt="img-3"/>
</p>
<p align="center">USB Type</p>

<br/>

USB로 전달되는 데이터는 `패킷`형태로 전송된다.   
패킷에는 `header`와 `payload`로 구성되어, 어디서 온 데이터인지, 어디로 갈 데이터인지, 크기는 얼마인지 등의 정보가 들어있다.   
또한, 음향과 비디오를 `등시성 전송`(isochronous transfer)를 통해 처리할 수 있다.   
모든 **endpoint** 는 데이터의 전송을 보장하기 위해 자신이 원하는 `대역폭`(bandwidth)을 설정해달라고 요청할 수 있다.   
이 때 충분한 대역폭이 없으면 **controller**는 데이터 전송 자체를 거절할 수 있다.

## 네트워킹

> LAN(근거리 네트워크)

Local Area Network의 약자로 사용자가 포함된 지역 네트워크를 의미한다. 이더넷이라는 프로토콜을 주로 사용한다.

<div align="center">

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F22341E365491D9C22D51CA)

</div>

<br/>

> WAN(광역 네트워크)

LAN과 LAN 사이를 광범위한 지역 단위로 구성하는 네트워크를 의미한다. ISP(Internet Service Provider)가 제공하는 서비스에 의해 구축된 네트워크이다.

<div align="center">

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F234D04425491D9C50A24F3)

</div>

<br/>

> 네트워크의 종류

- `PAN(Personal Area Network)` 가장 작은 규모의 네트워크
- `LAN(Local Area Network)` 근거리 영역 네트워크
- `MAN(Metropolitan Area Network)` 대도시 영역 네트워크
- `WAN(Wide Area Network)` 광대역 네트워크
- `VAN(Value Added Network)` 부가가치 통신망 정보의 축적과 제공, 통신속도와 형식의 변화, 통신경로의 선택 등 여러 종류의 정보서비스가 부가된 통신망.
- `ISDN(Integrated Services Digital Network)` 종합정보 통신망(=BISDN) 전화, 팩스, 데이터 통신, 비디오텍스 등 통신관련 서비스를 종합하여 다루는 통합서비스 디지털 통신망. 디지털 전송방식과 광섬유 케이블 사용.

<br/>

> 데이터 교환 방식

- `Point to Point 교환방식` 중앙컴퓨터와 터미널이 1대1로 독립적이고 직접적으로 연결. 가장 단순한 형태이다.
- `회선 교환방식(Circuit Switching)` 중앙컴퓨터와 터미널 간에 통신 회선을 설정하여 미리 정해진 경로에 따라 데이터를 교환.
- `Packet 교환방식(Packet Switching)` 패킷형태의 데이터를 송신측 패킷교환기에 저장하였다가 수신측의 요청으로 수신측 패킷 교환기에 전송하는 방식.
- `메시지 교환방식(Message Switching)` 데이터의 논리적 단위를 교환. 회선교환방식의 단점을 보완 하였다. 데이터의 크기에 제한이 없고 디지털 교환에 적합.
- `Multi Point 방식` 하나의 회선을 여러 개의 단말기로 연결한 다중 교환 방식.

<br></br>

### 최근의 LAN들

> MAC 주소

MAC 주소는 컴퓨터간 데이터를 전송하기 위해 있는 컴퓨터의 물리적 주소이다. 평소 통신하기 위해 IP 주소를 사용한다고 하지만 실제로는 IP 주소를 MAC 주소로 바꿔서 사용하는 것이다. IP는 시작점과 끝점에 해당하는 주소라면 MAC은 바로 옆에서 물리적으로 연결되어 있는 노드와 통신할 때 사용되는 주소를 의미한다. 따라서 IP 주소간의 통신은 MAC 주소간의 통신이라고 하는 것이다. MAC 주소는 데이터링크 계층에서 사용되고 IP 주소는 네트워크 계층에서 사용된다고 한다.
MAC 주소를 하드웨어 주소라고도 한다. 컴퓨터 하드웨어만 가지고 있는 식별번호이며 하드웨어를 구분하기 위한 주소이다. IP 주소는 변동가능성이 있지만 MAC 주소는 절대 변하지 않는 고유 주소이다.

<br/>

> 프레임

OSI 7Layer 중 2계층인 Data Link 계층에서 전송되는 단위로 전송 프레임에는 상위 계층에서 보낸 전송 데이터에 오류 확인을 위한 체크섬, 송수신 호스트의 주소, 기타 프로토콜에서 사용하는 제어 코드 등의 정보가 포함된다. 프레임을 전송받은 호스트는 체크섬 에러를 확인하고 에러 및 변형 등의 오류를 체크한다. 에러 검출 시 재전송을 요구하여 복구 과정을 거친다.

<br></br>

### 인터넷

> TCP/IP

`TCP/IP`라고 알려진 인터넷 프로토콜 스위트(Internet Protocol Suite)는 인터넷과 이와 유사한 컴퓨터 네트워크 사이에서 정보를 주고받는 데 이용되는 통신 프로토콜의 모음이다. 인터넷 프로토콜 스위트의 기본 프로토콜은 전송 제어 프로토콜(Transmission Control Protocol: TCP)과 인터넷 프로토콜(Internet Protocol: IP) 있다.
TCP/IP는 온라인상의 안전하고 효율적인 데이터 전송의 필수 요건을 정의한다. TCP는 전송 제어 프로토콜(Transmission Control Protocol)의 약자이며 한 기기에서 다른 기기로 데이터 전송하는 것을 담당한다. IP는 인터넷 프로토콜(Internet Protocol)의 약자이며 데이터의 조각을 최대한 빨리 대상 IP 주소로 보내는 역할을 표시한다. 데이터 전송의 과정에서 TCP와 IP 각각 담당하는 작업이 있지만, 결국에는 같은 결과를 목표로 하기 때문에 이처럼 한 명칭으로 부르기도 한다.

<br/>

> IP 주소

`IP`란 인터넷 프로토콜(Internet Protocol)의 약자로 인터넷상에서 데이터를 주고 받기 위한 통신 규약이다. 통신이란 데이터를 주고 받아야 하는데 그러기 위해서는 출발지와 도착지가 있어야 한다. 그래서 생겨난 개념이 IP 주소이다.
IP를 0부터 255까지의 숫자 4마디로 구분되는 방식이 `IPv4`이다. 현재는 대부분 IPv4방식의 주소를 사용한다. IPv4는 0.0.0.0 부터 255.255.255.255까지의 주소를 사용하며 2의 32제곱, 대략 42억개의 주소를 나타낼 수 있다. 인터넷의 초창기에는 42억개란 숫자가 엄청나게 많은 숫자라고 생각되어 IPv4를 만들었지만 인터넷이 발달되면서 스마트폰, 모바일기기, 사물인터넷, PC 등이 폭발적으로 증가해 IP 주소가 고갈되어 가고 있다. 이와 같은 IP 주소 부족 문제를 해결하기 위해 제안된 새로운 IP 주소 체계가 `IPv6`이다. 이는 IPv4가 32개의 2진수로 처리하던 IP 주소를 128개의 2진수(128비트)로 처리하게 된다. 따라서, 2의 128제곱인 거의 무한대에 해당하는 IP 주소를 사용할 수 있게 된다. 이렇게 되면 비단 컴퓨터 관련 기기뿐 아니라, 냉장고, TV, 세탁기, 전자레인지 등 일반 가전에도 IP 주소를 부여할 수 있어 각 기기 간의 통신이 가능해진다.
기존의 IPv4 주소를 체계적으로 사용하기 위해 클래스라는 개념이 생겼다. IPv4 주소는 대역에 따라 클래스(class) A, B, C, D, E 등으로 나눌 수 있다. 클래스 A는 대규모 네트워크 환경에 쓰이며, IP 주소 4마디 중 첫 번째 마디의 숫자가 1~126(각 네트워크마다 1,600만 개 IP 주소 사용 가능)까지 사용된다. 클래스 B는 중규모 네트워크 환경용으로 129~191(각 네트워크 마다 65,000개 IP 주소 사용 가능)까지 사용된다. 클래스 C는 소규모 네트워크 환경에 적용되는 것으로 192~223(각 네트워크마다 254개 IP 주소 사용 가능)까지 사용된다. 클래스 D와 E가 223 이후의 숫자로 구성되는데, 이는 연구/개발용 IP 주소이므로 일반적인 용도로 활용되지 않는다.

<br/>

> DNS(도메인 이름 시스템)

DNS(Domain Name System)는 범국제적 단위로 웹사이트의 IP 주소와 도메인 주소를 이어주는 환경/시스템이다. 그리고 이 안에서 부분적으로 지 역할을 하는 서버를 풀네임으로 DNS 서버라고 한다.

<div align="center">

![](https://gentlysallim.com/wp-content/uploads/2021/03/210111_02.jpg)

</div>

웹사이트의 데이터가 저장되어 있는 호스팅 서버는 인터넷 회선이 연결된 컴퓨터/장치로 IP 주소가 할당되어 있고 이 주소가 실제 웹사이트 주소라 할 수 있다. DNS 서버는 이런 IP 주소를 특정 도메인 주소와 같다는 기록을 저장해두고, 인터넷 사용자들이 도메인 주소를 검색했을 때 IP 주소로 연결되도록 해준다.

<br/>

> 월드 와이드 웹(WWW)

인터넷에 연결된 컴퓨터를 통해 사람들이 정보를 공유할 수 있는 전 세계적인 정보 공간을 말한다. 간단하게 웹이라고 부르는 경우가 많다. 인터넷 웹과 같은 개념으로 혼동되기도 하지만 다른 개념이다. 인터넷은 TCP/IP를 기반으로 전 세계 컴퓨터를 연결한 네트워크이며, 웹 이외에도 다양한 서비스들이 포함되는 개념이다.
웹의 가장 큰 특징은 `하이퍼 텍스트(Hyper Text)`라는 것이다. 웹을 통해서 다른 웹 페이지와 연결되는 개념을 말한다. 하이퍼 텍스트 방식으로 연결된 웹 사이트에서 이미지, 영상, 텍스트 등의 멀티미디어를 접할 수 있다.

<br></br>

### 참고

- [네트워크(Network) 란?](http://jskp.co.kr/xe/NETWORK/2087)
- [LAN, WAN의 정의와 차이점](https://ledgku.tistory.com/17)
- [맥 어드레스란 무엇인가?](https://jhnyang.tistory.com/404)
- [프레임 패킷 차이를 아시나요?](https://ict-story.tistory.com/39)
- [TCP/IP란 무엇이며 어떤 원리로 작동하나요?](https://nordvpn.com/ko/blog/tcp-ip-protocol/)
- [IP주소란? IP주소의 개념과 이해](https://c0mp.tistory.com/927)
- [DNS란 뭐고, 네임서버란 뭔지 개념정리](https://gentlysallim.com/dns%EB%9E%80-%EB%AD%90%EA%B3%A0-%EB%84%A4%EC%9E%84%EC%84%9C%EB%B2%84%EB%9E%80-%EB%AD%94%EC%A7%80-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/)
- [WWW, 월드 와이드 웹(웹)의 개념과 기술 훑어보기](https://brunch.co.kr/@natrsci/88)


# 아날로그 처리 방법

컴퓨터는 연속적인 대상을 저장하기 위해 데이터의 `샘플(sample)`을 취한다. 즉 시간이나 공간상 일정한 간격으로 값을 읽어야 한다. 저장한 데이터를 다시 영상이나 빛으로 보여주려면 샘플링 데이터를 `아날로그 신호`로 변환해야 한다.

<br />

## 디지털을 아날로그로 변환

**DA 변환기**(digital-to-analog converter, D/A, DAC 디지털을 아날로그로 바꾸는 변환기)
DA 변환기로 전압을 만들어낸다.
![6-22 LED를 사용해 만든 더 나은 DA 변환기](https://cdn.discordapp.com/attachments/879215554379018243/990298835857317908/unknown.png)
8비트를 이용해 256 수준의 전압을 만들어낼 수 있다.

해상도: DAC가 만들어낼 수 있는 최대 전압을 단계 수로 나눈 값

- ex) 오디오, 음악 신디사이저
- DAC 입력을 일정한 비율로 변경하면 파형을 만들 수 있다.

![톱니파 합성하기](https://cdn.discordapp.com/attachments/879215554379018243/990296465047957544/IMG_9722.jpg)

- 더 복잡한 파형을 만들려면 데이터를 써넣기 위한 **메모리**가 들어있다.
  메모리에 있는 데이터를 읽고, CPU가 수행하는 다른 작업과 무관하게 데이터를 일정한 비율로 읽어서 처리한다. 이 과정에서 `FIFO` 설정을 만들어 구현한다.

![높은 워터마크와 낮은 워터마크가 있는 FIFO](https://media.discordapp.net/attachments/879215554379018243/990296461797388318/IMG_9722.jpg?width=781&height=226)

FIFO 메모리에는 두 가지 트리거가 있다.

- **높은 워터마크(high-water mark)**
  - FIFO가 거의 꽉 찼을 때 인터럽트 발생
- **낮은 워터마크(low-water-mark)**
  - FIFO가 거의 빈 상태일 때 인터럽트를 발생

FIFO는 각기 다른 속도로 동작하는 여러 요소를 결합할 때 유용하다.

<br />

## 아날로그를 디지털로 변환

**AD 변환기**(analog-to-digital converter, A/D, ADC)
값을 측정할 수 있도록 아날로그 신호의 현재 값을 흔들리지 않게 안정적으로 잡아내야 한다. => **샘플**을 얻는다.

디지털화한 파형이 아날로그 파형과 닮기 위해서는 여러 번 샘플을 얻어야 한다. **샘플 앤드 홀드**(sample and hold) 회로를 사용해 아날로그 파형 값을 잡아낸다.

![샘플 앤드 홀드](https://cdn.discordapp.com/attachments/879215554379018243/990296920595521556/unknown.png)

스위치를 닫아서 샘플을 얻으면 아날로그 신호의 현재 값이 `저장 탱크`에 저장된다. `저장 탱크`에 안정적인 값이 들어있어 이를 측정해 디지털 값을 만들어낸다.
<br />

**비교기**
어떤 문턱값과 신호를 비교하는 장치로 `비교기(comparator)`을 사용한다. `비교기`는 문턱값을 선택하는 논리게이트와 비슷하다.

![아날로그 비교기](https://cdn.discordapp.com/attachments/879215554379018243/990299600046940242/unknown.png)

비교기의 `+` 입력 신호가 `-` 보다 크거나 같다면 출력 = 1, 그렇지 않으면 0이다.

<br />

**플래시 변환기**
비교기를 여러 `기준 전압`과 연결해 쌓으면 `플래시 변환기`를 만들 수 있다.

![플래시 변환기](https://media.discordapp.net/attachments/879215554379018243/990296461893853214/IMG_9724.jpg?width=496&height=495)

비트를 효율적으로 사용하지 못하고, 비교기를 많이 사용해야 해서 비싸다.
기준 전압을 변화시킬 수 있으면 비교기를 하나만 사용해도 되므로, `DAC`를 이용해서 기준 전압을 얻는다.

**AD 변환기(램프 변환기)**
![AD 변환기](https://cdn.discordapp.com/attachments/879215554379018243/990297255263240242/unknown.png)
`저장 탱크의 샘플값`과 `DAC`값을 비교하기 위해 비교기를 사용한다. Clear가 활성화되면 샘플값이 DAC 값과 같아질 때까지 카운터가 수를 센다. 값이 같아지면, 비교기의 출력이 0이 되면서 카운터가 비활성화되고, 원하는 값을 얻고 끝난다. 카운터에는 샘플을 디지털로 변환한 값이 들어있다.

DAC 출력이 경사로를 올라가는 것처럼 변하기 때문에 이런 ADC를 `램프 변환기`라고 부른다. 그러나 이 변환기는 변환이 오래 걸린다.

이를 개선하기 위해 **연속 추정 변환기**(successive approximation converter)가 있다. 하드웨어로 **2진 검색**(binary search)를 진행한다.
![](https://cdn.discordapp.com/attachments/879215554379018243/990296668396212314/unknown.png)

첫 클록에 DAC의 전체 범위의 절반으로 설정한다. 이 값이 샘플보다 작으면 1/4만큼 더 증가한다. 값이 샘플보다 크면 1/8 만큼 감소한다. 이런 식으로 샘플 값과 일치하는 값을 찾는다.

# 디지털오디오


### `오디오를 디지털화 하는 방법`

일정 시간 간격으로 신호의 진폭이나 높이를 측정하는 `샘플링`을 통해 `디지털화`가 가능하다.

샘플링 주파수로 `사각파`를 얻을 수 있고 상승 엣지마다 `A/D`를 사용해 신호의 높이를 기록할 수 있다.

> 사인파

배음이 전혀 없는 파형으로, 수학적으로 사인 함수를 사용하면 완벽히 계산된다. 옛날부터 PC의 에러음을 내기 위해 활용되기도 하였다.

<img width="400" alt="image" src="https://user-images.githubusercontent.com/91880235/175751435-27aaf304-437b-4b2a-8dfa-bbc1bd78202c.png">

<br>

> 코사인파
> 
사인파와 비교하여 시작 위상이 90도가 차이가 남

<img width="344" alt="image" src="https://user-images.githubusercontent.com/91880235/175751814-7e0b7bd0-381d-4a7d-9663-a639e2c4518d.png">


<br>

> `사각파`

다수의 홀수배음을 가지고 있는 사각파 등이 있다.

<img width="320" alt="image" src="https://user-images.githubusercontent.com/91880235/175751874-0601ea83-4811-4e36-bd27-feb2260e6ef4.png">

<br>
<br>

악보를 생각 해 보면 하나의 음만 내는 게 아닌 다수의 음을 내는 코드가 존재한다. 
어떤 파형이든지 일련의 사인파의 가중치 합으로 표현할 수 있다.

<img width="467" alt="image" src="https://user-images.githubusercontent.com/91880235/175751695-dcd06dbe-33ae-4b4c-b60a-e7d51ee1e35d.png">

<img width="485" alt="image" src="https://user-images.githubusercontent.com/91880235/175751707-0e470f0f-7266-4f16-9d91-06e403a8c013.png">

절대 음감은 코드를 이루는 각 음을 골라낼 수 있지만
음을 제대로 들을 수 없는 사람들은 `푸리에 변환`이라는 수학적 묘기를 통해 구분할 수 있다.

<br>

### `푸리에 변환`

지금까지는 시간에 따른 진폭을 표현 했다.

`푸리에 변환`을 통해 주파수에 따른 진폭을 그래프로 그릴 수 있다.

`푸리에 변환`은 시간에 따른 파형과는 전혀 다르게 사물을 바라보는 방식이다.

아래의 그림은 G코드의 푸리에 변환을 나타낸 것이다.

<img width="279" alt="image" src="https://user-images.githubusercontent.com/91880235/175752289-be4ab980-b579-4d4f-9e52-c90ca1362ef6.png">

푸리에 변환은 신호처리, 음성, 통신, 영상 등 다양한 곳에서 쓰이며 관련 기술로는 `그래픽 이퀼라이저`, `필터`, `패스` 등이 있다.

- 이미지 필터
  
<img width="150" alt="image" src="https://user-images.githubusercontent.com/91880235/175752625-cf4eaf8b-a6a7-42be-bd65-057e8132fa7b.png">


- `로우패스`: 어떤 음보다 낮은 음만을 통과시킴
- `하이패스`: 어떤 음보다 높은 음만을 통과시킴
- `밴드패스`: 어느 주파수 이상, 이하의 음을 제거하여 통과시킴
- `노치`: 특정 주파수를 제외시킴
- 
<img width="519" alt="image" src="https://user-images.githubusercontent.com/91880235/175752704-d5286b29-a719-4e97-b3c4-66356d31eb50.png">

<br>

### `나이퀴스트 비율` 

스웨덴의 전기 엔지니어인 `해리 나이퀴스트`는 신호를 제대로 잡아내기 위해 적어도 최고 주파수의 2배의 샘플링 비율로 샘플을 얻어야 한다는 법칙을 발견함. = `나이퀴스트 비율`

인간의 가청 주파수는 20~2만Hz정도다.

이런 사실을 감안하면 40kHz 샘플링 비율로 사람이 들을 수 있는 모든 소리를 잡아낼 수 있다.
21kHz의 음향이 있고 40kHz로 샘플링하면(언더샘플링) `폴딩`이나 `에일리어싱`이 일어난다.

- `폴딩`: 주파수가 왜곡되는 현상
- `에일리어싱`: 주파수가 겹치는 현상

이러한 현상을 피하기 위해 `로우패스 필터`를 적용해서 `안티 에일리어싱`할 수 있다.

그럼 우리는 왜 더 높은 주파수를 써서 샘플링을 해야할까?

나이퀴스트 비율에 근접해 샘플링한 신호로부터 원래의 주파수와 진폭을 재구성할 수 있지만 `위상`은 재구성할 수 없다. 

<br>

### `위상` 
`위상`은 스테레오가 아니라면 크게 상관이 없다. `위상차`는 왼쪽과 오른쪽 귀에 도달하는 신호 사이의 시간차로 인해 발생하며 사람은 이를 통해 공간에서 소리가 발생한 위치를 인식한다.

<img width="478" alt="image" src="https://user-images.githubusercontent.com/91880235/175753710-565c9b5f-bd2a-4483-8b9e-4929ebb8d9eb.png">

<img width="316" alt="image" src="https://user-images.githubusercontent.com/91880235/175753712-8752ba61-db51-4c2a-a7ac-5fe2d79a36b0.png">


주파수가 높으면 귀 사이의 거리보다 파장이 더 짧기 때문에 위상차를 더 잘 알아챌 수 있대요.

머리가 큰 사람은 스테레오를 더 잘 느낀다!

서브 우퍼가 하나만 있어도 되는 이유는 두 귀 사이의 거리보다 음파 파장이 길어 위상차를 감지하기 힘들기 때문

두음이 만들어내는 위상차를 `이미지`라고 부르며 볼 수 있는 능력을 뜻한다. 위상이 정확하지 않으면 이미지가 탁해진다.

더 나은 위상과 스테레오 이미지를 얻기 위해서는 높은 샘플링 비율이 정당화 될 수 있다.

<br> 

### `무손실 압축, 손실 압축`
- `무손실 압축`: 원래 데이터를 그대로 유지하는 것으로 원래 데이터 크기의 절반 정도 수준으로 줄일 수 있다. (.flac, .alac 등이 있이 있으며 wav는 무손실 무압축이며 flac 용량의 2배가량이다.))
-  
- `손실 압축`: 손실압축은 반대의 의미로, 일부 세부 사항이 사라진다. 사람이 들을 수 없는 소리가 있다는 음향 심리학 원리를 사용해 작동한다. (하지만 귀가 좋은 사람들은 느낄 수 있다.. mp3, aac, ogg 등이 해당)

<br>




# 참고 
- [[신디사이저] 사인파(Sine Wave) 이야기](http://rennflav.blogspot.com/2014/07/sine-wave.html)
- [[신디사이저] 사각파(Square Wave) 및 PWM 이야기](http://rennflav.blogspot.com/2014/08/square-wave-pwm.html)
- [푸리에 변환.. 왔습니다. 그려서 보여드리겠습니다.](https://www.youtube.com/watch?v=Mc9PHZ3H36M)
- [오버샘플링, 업샘플링, 에일리어싱](https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=wyepark&logNo=221013968332&beginTime=0&jumpingVid=&from=search&redirect=Log&widgetTypeCall=true)
- [무손실 압축 - 나무위키](https://namu.wiki/w/%EB%AC%B4%EC%86%90%EC%8B%A4%20%EC%95%95%EC%B6%95%20%ED%8F%AC%EB%A7%B7)

# 디지털 이미지

<br/>

시각 이미지는 2차원 공간을 샘플링해야 하기 떄문에 오디오보다 더 복잡하다.   
디지털 이미지는 `picture element` 또는 `pixel` 로 이루어진 직사각형 배열로 표현된다.   
각 픽셀은 [ `빨간색`, `초록색`, `파란색` ] 3가지 색상의 조합으로 표현되고, 각 색상은 `8비트` 를 차지한다.

또한 컴퓨터는 `가산 혼합` 을 사용해 색을 표현한다. -> `빨간색`, `초록색`, `파란색`   
인쇄에 쓰이는 `감산 혼합` 과는 다르다. -> `사이언(청록색)`, `마젠타(자홍색)`, `노란색`

<br/>

```
📍 그럼 각 색상은 "8비트" 로만 표현 가능한걸까 ? 
   : Nope. 디스플레이가 얼마나 많은 색을 표현할 수 있는 정도를 나타내는 "색심도" 라는 개념이 존재하고, 색은 다양한 비트의 조합으로 표현될 수 있다.
```

<br/>

<p align="center"> 
  <img width="500" src="https://user-images.githubusercontent.com/80025242/175792776-38fc19f0-56c0-40ed-9c0c-73d7e493e7ce.png" alt="색심도 이미지"/>
</p>

<br/>

```
🔓 각 색상이 0과 1, 즉 색이 없다 & 있다 2가지 경우의 수로만 표현된다고 했을 때 나올 수 있는 색조합이다.   
   : 색상이 갖는 경우의 수가 다양해질수록 색의 표현도가 높아지고 자연스러워진다. 
```

<br/>

<p align="center">
  <img width="500" src="https://user-images.githubusercontent.com/80025242/175792850-e302f6de-5ff9-4202-b942-01ca2cf3dfcd.png" alt="3비트 색표현"/>
</p>

<br/>

```
흔히 색상 picker 로 사용되는 이미지가 8비트의 색상 표현 방식이다. 
그래서 각 색상은 8비트를 가진다고 통용된다.
-> 한 가지 색상마다 연함과 진함 정도를 얼마나 세분화시켰는지 보면 된다.

현재 대부분의 TV, 모니터, 스마트폰 등 IT용 디스플레이들은 1픽셀이 8비트로 구성된 
픽셀당 24비트(8+8+8)의 색심도를 표현하며, 약 1,677만 컬러를 표현한다.
```

<br/>

<p align="center">
  <img width="500" src="https://user-images.githubusercontent.com/80025242/175792970-f34d27d2-6a7e-4f3b-a1e2-2da80535bb1d.png" alt="비트에 따른 계조표현"/>
</p>

<br/>

```
32비트(8+8+8+8)의 경우 나머지 8비트는 투명도를 나타낸다고 앞장에서 배웠다 !
```

<br/>

<p align="center">
  <img width="500" src="https://user-images.githubusercontent.com/80025242/175792583-f8d2a99c-9825-4f30-a4c4-5d442c6ee67a.jpeg" alt="img-1"/>
</p>

<br/>

이미지를 샘플링하는 작업은, 이미지 앞에 모눈 종이를 놓고 각 네모칸의 색을 기록하는 것과 비슷하다.   
-> `샘플링` 이란 개념은, <b>무한한 데이터 속에서 유한한 개수의 데이터를 뽑아내는 것을 말한다.</b>    
-> `샘플링` 작업은 굉장히 다양한 알고리즘을 바탕으로 이루어지는데,    
    이렇게 정사각형 전체의 색을 기록하는 게 아니라 정사각형 중심점의 색을 기록하는 것을 `포인트 샘플링` 이라고 한다.

<br/>

<p align="center">
  <img width="250" src="https://user-images.githubusercontent.com/80025242/175793430-91189396-7afd-46ad-bae7-21debb529f44.png" alt="샘플링 알고리즘 종류"/>
</p>

<br/>

높은 해상도를 사용하면 샘플링한 이미지의 수준이 당연히 올라간다. 하지만 그에 따라 데이터의 양도 늘어난다.   
또한 해상도가 높더라도 픽셀의 삐죽삐죽함은 여전하다. 이를 필터링할 수 있는 방법으로 `슈퍼 샘플링` 을 사용하기도 한다.   
-> `슈퍼 샘플링` 작업도 다양한 알고리즘으로 진행된다.   
-> 보통은 한 정사각형 안에서 여러 지점의 색을 얻어서 평균을 내는 방식이라고 이해하면 된다.   
-> `슈퍼샘플링`은 앤티에일리어싱 기술의 하나로, 울퉁불퉁한 화소 모서리(에일리어싱)를 없애는 과정이다.   
-> 컴퓨터 게임이나 영상을 만들어내는 다른 프로그램들이 표현하는 영상을 부드럽게 하는 방식이기도 하다.   
-> 일반 `샘플링` 보다 정교하게 표현된 것처럼 느껴진다.

<br/>

<p align="center">
  <img width="500" src="https://user-images.githubusercontent.com/80025242/175793641-2a60b1f2-ce00-406a-9118-2bae48a14617.png" alt="슈퍼 샘플링 알고리즘 종류"/>
</p>

<br/>

우리가 사용하는 이미지는 점점 커지고 있고, 그에 따라 공간도 많이 차지한다. (내 아이폰 용량만 봐도 사진이 ...)    
같은 메모리라도 더 많은 사진을 저장하고, 네트워크를 통해서도 더 빨리 전송하고 싶다.   
그래서 `이미지 압축` 의 개념이 등장한다.   

가장 일반적인 방식은, `JPEG` 이다. (Joint Photographic Experts Group(JPEG) : 연합 사진 전문가 그룹)     
-> JPEG 작동 방식은 이웃한 픽셀의 색이 서로 비슷할 가능성이 높다는 가정하에,    
   개별적인 픽셀의 색을 저장하는 대신 이웃한 픽셀의 색에 대한 표현을 저장하는 방식으로 이해하면 좋다 !!
   
<br/>
   
```
📍 그럼 JPG 와 JPEG 차이는 무엇인가 ? 
   : 이전 윈도우에서 3글자의 확장자를 필요로해서 JPG 확장자가 등장한 것이다. JPG 와 JPEG 는 동일하다.
```

<br/>

```
📍 JPGE 와 PNG 의 차이는 무엇인가 ? 
   : JPEG 는 손실 압축 방식이고, PNG 는 비손실 압축 방식이다.
   : 동일한 이미지를 여러번 JPEG 확장자로 저장한다면, 계속해서 원본이 훼손되므로 저장 횟수를 줄이는 것이 좋다 !!
```
   
   
<br/>
<br/>

# 비디오

<br/>

비디오는 2차원 이미지를 일정한 시간 간격으로 샘플링한 시퀀스이다.   
오래된 영화는 초당 24프레임(fps : frame per second)으로 샘플링했었다고 ..! (요즘은 못해도 48fps)   
비디오도 이미지와 같이 픽셀로 표현했을 때 부자연스러운 부분들은 `슈퍼 샘플링`을 사용해 시각적인 아티팩트를 줄인다.

<br/>

<p align="center">
  <img width="500" src="https://user-images.githubusercontent.com/80025242/175794112-5e98587d-beae-4328-9e2a-0937ebeff623.png" alt="프레임 수에 따른 변화"/>
</p>

<p align="center">
  <img width="500" src="https://user-images.githubusercontent.com/80025242/175794154-203cf0a5-79cd-498a-b490-34ae9cb11ba7.jpeg" alt="프레임 수 종류"/>
</p>

<br/>

비디오는 이미지나 오디오보다 훨씬 훨씬 더 많은 정보를 만들어내기 때문에 압축 방식이 더 중요해진다.   
(UHD 비디오 해상도는 3,840 * 2,160 픽셀 -> (픽셀 * 3바이트:삼원색 8비트) * 초당 60fps -> 1,492,992,000 바이트)   
비디오 압축의 핵심은, 비디오 프레임과 프레임 사이에 이미지 중 아주 일부만 변한다는 사실이다.   

<br/>

<p align="center">
   <img width="500" src="https://user-images.githubusercontent.com/80025242/175794437-91b9458a-1377-4236-81fe-a617bfab1566.png" alt="프레임 간 차이"/>
</p>

<br/>

이렇게 변경된 영역의 데이터만 필요하다면 데이터를 전송하거나 저장할 때 더 적은 메모리를 사용할 수 있다.   
이런 기법을 `motion compensation` 이라고 한다.

이렇게 원본 이미지에서 변경된 내용의 집합으로 압축시키는 방식의 문제점은, 데이터가 왜곡될 수 있다는 점이다.    
ex. (원본 데이터가 깨져있을 때) 고장난 비디오 디스크를 플레이했을 때 화면이 네모 블록 단위로 깨지는 현상   

데이터를 복구하는 방식으로 "정기적으로 데이터에 `keyframe` 을 추가하는 방식" 을 사용해 해결한다.   
`키프레임` 은 완전한 이미지로서 원본 데이터가 손상된 경우라도 전체 이미지를 복구해 송출시킬 수 있게 된다.   

프레임과 프레임 사이의 차이를 감지하는 알고리즘은 아주 복잡하고, 계산이 많이 필요하다.   
MPEG4 와 같은 새로운 압축 표준은 `layering(레이어링)` 을 지원하여, 여러 레이어가 합쳐져 화면이 동작하는 것처럼 구성한다.   
레이어 간에 각기 다른 그림을 중첩시켜서 비디오 이미지를 만들 수 있다.

<br/>
<br/>
<br/>

<b>참고 자료</b>

[색심도의 표현](https://news.samsungdisplay.com/14657)   
[샘플링이란](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=undergrd&logNo=220403550837)   
[멀티미디어 압축 기술의 기초](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=chacagea&logNo=220965514815)

# 휴먼 인터페이스 장치
컴퓨터와 사람과의 상호 작용 


## 터미널

> 배치 프로세싱(batch processing)

과거 종이에 특별하게 정해진 코딩 양식으로 데이터나 프로그램을 기록해 키펀치를 사용해 펀치카드를 만들고  
그 펀치카드를 컴퓨터에게 읽게 해서 프로그램을 실행함.  
비싸고 느리다.  
  
> 텔레타이프(teletype)

전산타자기를 컴퓨터에 연결  
전산타자기의 끝에 컴퓨터가 연결 되어 `터미널(terminal)`이라 불렀다.  
초기의 메인프레임이나 미니컴퓨터에서 컴퓨터로 타자된 데이터를 전송하고 컴퓨터의 반응을 출력하며 명령 줄 인터페이스 역할  
텔레타이프를 줄인 `TTY`은 여전히 터미널을 가리키는 데 사용  
  
> 시분할(time sharing)
```
내가 타이핑을 하는 5초동안 다른 사용자의 프로그램을 수행하도록 전환
```
끊임없이 컴퓨터를 사용하기 위해 발명  
처음 컴퓨터는 여러 자원을 각 사용자에게 배분  
  
`스왑 인(swap in)` 디스크에서 메모리로 옮겨짐  
`스왑 아웃(swap out)` 메모리에서 디스크로 옮겨짐  

컴퓨터를 사용할 순서가 되면 디스크에서 메모리로 스왑 인, 다른 사용자의 프로그램은 스왑 아웃  
  
`스레싱(thrashing)` 프로그램을 스왑 인하고 스왑 아웃하는데 소모하는 시간이 프로그램 실행 시간보다 길어지는 경우  
`멀티태스킹(multitasking)` 시분할 시스템을 이용해 여러 작업이 동시에 일어나는 것 처럼 보이게 하는 시스템  
`사용자(user)` 해당 작업이 어디에 종속되었는지 구분하기 위한 개념
  
`운영체제(OS)`  
컴퓨터를 시스템의 각종 하드웨어 자원과 소프트웨어 자원을 효율적으로 운영 관리함으로서 사용자가 시스템을 이용하는데 편리함을 제공하는 시스템 소프트웨어  
  
  
  
## 그래픽 터미널
기존 종이 터미널에서 스크린으로 전환  

> CRT

브라운관 방식의 디스플레이  
`음극선관(cathode ray tube)`라는 진공관의 유리 내부에 인광물질을 발라 여기에 전자가 부딪히면 빛이 난다.  

> LCD(액정 디스플레이)

`액정` 고체와 액체의 성질을 동시에 가지는 물질  
평상시에는 액정이 불규칙적으로 배열되어 편광판을 통과한 빛의 방향을 비틀어 수직으로 세워진 편광판을 통과하게 하지만  
전류가 흐를 때는 액정의 배열이 규칙적으로 변화하여 2차 편광판에서 빛이 걸러지게 된다.  
CRT 장치에 비해 공간을 덜 차지한다.  
백라이트로 발광 다이오드(LED)를 사용  

> OLED(유기 발광 다이오드)

전류가 흐르면 스스로 빛을 내는 유기물질을 이용  
백라이트 광원을 활용해 액정과 컬러필터를 거쳐 색을 표현하는 LCD와 달리  
OLED는 유기발광층에 전류를 가했을 때 이에 반응하는 빛의 3원색인 RGB 발광물질을 통해 색을 표현  
  
`LED` 전류를 가하면 빛을 내는 반도체 소재  
LCD 장치에서는 금속 소재를, OLED 장치에서는 유기 소재를 사용  

![lcd-oled](https://user-images.githubusercontent.com/91672778/175760085-b3e53536-8358-42af-8c6a-dc20ffdff6c6.png)


## 벡터 그래픽(vector graphics)
선 혹은 벡터로 그림을 그리는 방식  
![image](https://user-images.githubusercontent.com/91672778/175760536-86695929-2150-4376-a8f4-877132c20c6d.png)  
이미지에 표현되는 점에 대한 정보를 저장하여 이미지를 표현  
해상도를 변경해도 이미지가 손상되지 않는다  
이미지가 복잡할 수록 저장공간을 매우 많이 차지한다  
SVG파일  

> 해상도(resolution)
인치 당 표시할 수 있는 픽셀의 개수 -> 밀도  
  
`픽셀(pixel)` 화면 구성에서의 기본 단위  
  
  
  
### 참고자료
- [운영체제(Operating System:OS)란 ? 운영체제 종류와 목적, OS 정복](https://jhnyang.tistory.com/16)
- [LCD 디스플레이와 LED디스플레이의 차이](https://onna.kr/313)

### 래스터 그래픽(Raster graphics)

`래스터(Raster)`란, '화소'를 의미한다. 하나의 화소는 R, G, B 색을 띄고 있는 인점(Phosphor Dot)으로 구성되어 있다. 화면에 '인'이라는 형광 물질이 입혀져 있기 때문에 인점이라고 한다. 이 3가지 인점의 밝기에 따라 화소 하나의 색상이 결정된다.

래스터 그래픽은 벡터와 다르게 많은 양의 픽셀이 모여 하나의 이미지를 구성하는 방식이다. 비트의 지도라는 뜻에서 비트맵(Bitmap)이라고 불리기도 한다. 비트맵은 픽셀의 숫자가 많을수록 고화질이 된다. 래스터 이미지 방식은 다양한 색상이 쓰인 3D 모델이나 고해상도 사진을 표현할 때 주로 사용한다.

래스터 방식의 그래픽은 이미지의 좌측 위에서 우측 하단까지 화면의 모든 픽셀 위치들을 스캔한다. 이미지상의 가로 선을 하나씩 내려가면서 스캔하는 것이다. 하지만 직선을 그릴 때 완전한 직선을 그릴 수 없고 픽셀에 따라 `에일리어싱(aliasing, 계단 현상)`이 발생할 수 있다.

<div align="center">

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbW0QWu%2FbtqvVSy3nek%2F3n37FdtOrLpaUM6DD1914K%2Fimg.png)

</div>

<br/>

- 벡터 그래픽과의 비교

<div align="center">

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FoyBCg%2FbtqyLJj5Ix0%2Fhd4jBX6QlDeOeca96UdpS1%2Fimg.jpg)

</div>

<br></br>

### 키보드와 마우스

<div align="center">

![](https://t1.daumcdn.net/cfile/tistory/2164363D587159DA25)

</div>

<br></br>

### 참고

- [[컴퓨터 그래픽] 3. 벡터(Vector)와 래스터(Raster) 비교](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=ndb796&logNo=221115210469)
- [래스터 그래픽 장치 & 벡터 그래픽 장치
  ](https://dely.tistory.com/27)
- [래스터 이미지와 픽셀](https://cosmotree.github.io/mara-studio/Raster-and-Pixels/)
- [입력 Device의 원리 (1) - 키보드의 작동 원리](https://kylog.tistory.com/11)