# 메모리

### 메모리란

컴퓨터를 조작할 비트들을 저장할 장소

### 주소

메모리 안에 무수히 많은 크기가 같은 집들이 있고 정해진 개수 만큼의 비트를 저장할 수 있는 방이 있다. 이런 집마다 주소가 부여된다.  
32비트 컴퓨터는 메모리를 4바이트 덩어리로, 64비트 컴퓨터는 8비트 덩어리로 구성한다.  
덩어리가 커질수록 더 많은 양의 데이터를 처리할 수 있다.

### 엔디안(endian)

컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법.

     빅 엔디안
       큰 단위가 앞에 나온다. ex) 모토로라 프로세서

     리틀 엔디안
       작은 단위가 앞에 나온다. ex) 인텔 프로세서

오늘날의 프로세서는 여러개의 바이트를 동시에 읽어들여 동시에 덧셈을 수행하는 구조를 갖고 있어 두 엔디언 사이에 사실상 차이가 없다.

참고자료

- [[위키백과] 엔디언](https://ko.wikipedia.org/wiki/%EC%97%94%EB%94%94%EC%96%B8)

# 입력과 출력

### I/O 장치

ex) 프린터, 하드디스크, 키보드, 마우스  
`입력(input)`/`출력(output)` 장치로 컴퓨터에 정보를 전달하거나 정보를 가져올 때 사용  
주변부에 위치해 `주변장치(peripheral device/peripheral)`라 부른다.

과거에는 메모리가 부족해 I/O와 메모리의 연결을 분리했지만 현재는 메모리 중 일부를 I/O장치에 할당한다.  
많은 컴퓨터에는 설계상 입력 출력 `슬롯(slot)`이 있어 일관된 방식으로 I/O장치를 연결할 수 있다.

# 중앙 처리 장치

중앙 처리 장치 CPU는 실제 계산을 처리하는 컴퓨터 부품이다. CPU는 다음과 같이 다양한 요소로 이루어져 있다.

### 산술 논리 장치 \_ ALU (arithmetic logic unit)

CPU의 핵심 부품으로 산술 계산, 불리언 대수 및 기타 연산을 수행하는 방법을 알고 있는 장치이다.

![ALU예시](https://cdn.discordapp.com/attachments/879215554379018243/982160407139581972/unknown.png)

- **피연산자**: 수를 표현하는 비트
- **연산 코드(명령 코드)**: 피연산자에 대해 ALU가 어떤 연산자를 적용할지 지정한다.
- **결과**: 피연산자에 연산자를 적용한 결과
- **조건 코드**: 결과에 대한 추가 정보. 보통 조건 코드 레지스터라는 레지스터에 저장된다.

    <br />

  ![조건 코드 레지스터](https://cdn.discordapp.com/attachments/879215554379018243/982160473849987092/unknown.png)

  박스 위의 숫자는 비트 번호이다. 비트 번호로 각 비트를 편리하게 가리킨다. 비트 중 일부는 사용하지 않는다.

  - **N 비트**: 마지막으로 수행한 연산 결과가 `음수`인 경우 1이 된다.
  - **Z 비트**: 마지막 연산 결과가 `0`인 경우 1이 된다.
  - **O 비트**: 마지막 연산에서 `오버플로우(overflow)`, `언더플로우(underflow)`가 생긴 경우 1이 된다.

**ALU 명령 코드**
ALU가 할 수 있는 일은 아래와 같다.

![ALU 명령 코드](https://cdn.discordapp.com/attachments/879215554379018243/982162824128253982/IMG_9592.jpg)

<br />

ALU는 앞서 배운 실렉터와 논리 게이트를 연결한 것일 뿐이다.
![ALU 내부](https://media.discordapp.net/attachments/879215554379018243/982162823058706462/IMG_9593.jpg?width=363&height=378)

<br />

### 시프트

- **왼쪽 시프트**

  1. 어떤 숫자의 모든 비트를 왼쪽으로 1비트 씩 옮긴다.
  2. 맨 왼쪽 비트는 버린다.
  3. 비게 되는 가장 오른쪽 비트에 0을 넣는다.
     ex) 01101001(105) => 11010010(210)

  - 어떤 수를 1비트 `왼쪽 시프트` 한다. = 그 수에 `2를 곱한 것`과 같다.
    <br />

- **오른쪽 시프트**
  1. 어떤 숫자의 모든 비트를 오른쪽으로 1비트씩 옮긴다.
  2. 맨 오른쪽 비트는 버린다.
  3. 비게되는 가장 왼쪽 비트에 0을 넣는다.
     ex) 01101001(105) => 00110100(52)
  - 어떤 수를 `오른쪽 시프트` 한다. = 그 수를 `2로 나누고 나머지를 버린 값`과 같다.

왼쪽 시프트 혹은 오른쪽 시프트 시 사라지는 비트는 종종 필요할 때가 있다. 그래서 이 비트를 `조건 레지스터`에 저장한다.

**순차적인 시프트 레지스터**
시프트를 제외한 ALU의 모든 기능은 조합 논리로 구현할 수 있다.
![순차적인 시프트 레지스터](https://cdn.discordapp.com/attachments/879215554379018243/982638588892168292/unknown.png)

위와 같이 클록에 따라 내용을 1비트씩 시프트하는 시프트 레지스터를 `플리플롭`을 이용해 만들 수 있다. 여기서 1비트를 시프트 할 때, 1 클록이 필요하기 때문에 느리다.

**배럴 시프터**
배럴 시프터를 사용하면 느린 문제를 해결할 수 있다.
![배럴 시프터](https://cdn.discordapp.com/attachments/879215554379018243/982637409768460368/IMG_9606.jpg)

8비트 시프터를만들려면, 8:1 실렉터가 8개 필요하다.

위의 ALU에서 곱셈과 나눗셈 연산이 없는데, `곱셈`은 덧셈을 반복해 순차 논리로 구현하거나, 왼쪽 시프트가 어떤 수를 2로 곱하는 것곽 같다는 점을 이용해 배럴 시프터와 가산기를 조합하는 `조합논리 곱셈기`를 만들 수 있다.

또, 시프터를 이용해 부동 소수점 연산을 구현할 때도 핵심 부품이다. 두 피연산자의 가수를 지수에 따라 시프트 해 소수점을 정렬하고, 서로 더하거나 뺀다.

<br />

### 실행 장치(Execution unit, 제어장치)

메모리의 정해진 장소에서 `명령 코드`와 `피연산자`를 가져와 `ALU`에게 어떤 연산을 수행할지 알려주고, 결과를 메모리에 돌려준다.

**명령어**

- 컴퓨터에게 어떤 일을 할지 알려주는 `비트 패턴`
- 명령어의 `비트 패턴`은 CPU마다 고유한 설계에 속한다.
- 공통 표준이 없다

**프로그램 저장 방식 컴퓨터 (program counter, PC)**

- 실행 장치는 `프로그램 저장 방식 컴퓨터`(stored-program computer)를 이용해 메모리에서 명령어를 찾는다.
- 레지스터의 일종으로 메모리와 별도로 위치한다. `순수 레지스터`가 아닌 `레지스터`에 `카운터` 기능을 추가한 것이다.
- `메모리 주소`가 들어있어, 실행장치가 PC가 가리키는 `주소`에서 명령어를 가져온다.
- 명령을 수행하고 하면 다음 명령어를 가져오기 위해 `PC가 증가`한다.
- CPU마다 `초기 PC 값`이 있어, CPU의 전원이 들어오면 이 값으로 PC가 설정된다. (이 때 PC 값을 `리셋 벡터`라고 부른다.)

<br />

# 명령어 집합

### 명령어

명령어(instruction)는 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴이다. 명령어는 크게 `Operation Code(명령부: 연산코드)`와 `Operand(자료부: 연산에 사용되는 자료 값, 자료가 저장 된 주소에 관한 정보)`로 구성되며, Operand 개수에 따라 0주소 명령어부터 3주소 명령어까지 4가지 명령어 형식이 있다. 그중 책에는 3주소 명령어와 1주소 명령어가 소개되어 있다.

<div align="center">

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpfJmj%2FbtqEwgql2cw%2FS9tPTucFINkhkqvredZO8K%2Fimg.png)

</div>

`3주소 명령어`는 Operand 3개를 포함하는 명령어로 레지스터의 주소를 저장하는 명령어 형식이다. 연산 결과는 operand 3(주소 3)에 저장된다. 3주소 명령은 1개의 명령어로 여러 개의 명령을 수행하므로 전체 명령어를 읽어오는 시간은 단축되지만, 3개의 operand를 사용하지 않는 경우라도 최소한 4번 기억 장소에 접근해야 하므로 전체 수행시간이 길어지는 단점이 있다. 또한, 3가지 메모리 위치를 한꺼번에 지정하는 메모리 주소 접근을 사용하기 때문에 주소 버스와 데이터 버스가 3개씩 따로 존재한다. 이때 연산 결과를 다른 곳의 연산에 넘겨주기 위해 결과가 들어 있는 메모리 장치의 데이터를 전송하기 위해 별도의 명령어를 사용해야 한다. 그리고 CPU 패키지의 입출력 핀 수가 제한되어 있기 때문에 데이터 버스와 주소 버스를 하나만 두고 메모리 장치를 공유해야 한다.

<br/>

> 시스템 버스(System bus)

컴퓨터의 구성 요소를 서로 연결하고 데이터 전달을 위한 경로로, 주소 버스, 데이터 버스, 제어 버스로 구성된다. 각 구성요소(CPU, 메모리, I/O Unit)는 양방향으로 데이터 전달이 가능한 버스를 사용한다.

<div align="center">

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FxmVLL%2FbtqFElQFe4F%2F4bgtPArnBZ6dykKE4xwGy1%2Fimg.png)

</div>

1. 주소 버스(Address Bus)

- 메모리의 주소나 I/O Unit의 포트 번호를 전달

- CPU와 메모리는 단방향으로 데이터 전달이 가능한 버스를 이용함으로써 주소 전달은 CPU에서 메모리로만 가능

2. 데이터 버스(Data Bus)

- 데이터 전달

3. 제어 버스(Control Bus)

- 제어 신호 전달

- Read와 Write 신호가 전달

<br/>

요즘 컴퓨터는 일반적으로 32비트와 64비트 시스템을 많이 사용한다. 여기서 말하는 비트 수는 명령을 한 번에 처리할 수 있는 레지스터의 비트 수 또는 레지스터의 저장 가능 공간의 크기라고 할 수 있다. 책에서 먼저 가정한 16비트 시스템은 느리고 불안정하다. 표현할 수 있는 주소 공간이 협소하기 때문이다.

<br/>

> 누산기(accumulator)

`누산기`는 CPU 내에서 `ALU의 계산 결과를 저장하는 레지스터`를 말한다. 한 메모리 위치에 있는 값과 누산기에 있는 값에 대해 연산을 수행하고 결과를 누산기에 넣는다. 이를 통해 1주소 명령어 구성으로 바꿀 수 있다.
만약 누산기가 없다면 덧셈이나 곱셈 및 자리이동 등과 같은 각 계산의 결과를 주기억장치에 기록할 수 밖에 없고 필요한 경우 다시 읽어와야 한다. 누산기는 ALU로 직접 통하는 통로를 가지고 있기 때문에 주기억장치에 읽고 쓰는 것보다 훨씬 빠르다. 누산기는 처음에는 0으로 설정되며, 각 숫자는 차례로 누산기 내에 있는 값에 더해진다. 그리고 모든 숫자들이 다 더해졌을 때에만 그 결과가 주기억장치에 기록된다.

<br></br>

### 주소 지정 모드(Addressing mode)

위와 같이 누산기를 사용하는 '직접 주소 지정 방식' 대신 `간접 주소 지정`을 통해 더 많은 메모리를 사용할 수 있다. CPU는 명령어에 들어 있는 값을 피연산자 주소로 해석하지 않고, 피연산자 주소를 얻을 수 있는 "메모리 위치"를 가리키는 주소로 사용한다.
이 2가지 주소 지정 모드 외에도 상수를 지정해야 할 때에는 `즉시 주소 지정 모드`를 사용한다. 주소에 해당하는 비트를 그냥 값으로 간주한다.

<br></br>

### 조건 코드 명령어

- `cca` 조건 코드 레지스터의 값을 누산기로 복사
- `acc` 누산기의 값을 조건 코드 레지스터에 복사

<br></br>

### 분기 명령어

분기(branch) 명령어는 프로그램 카운터의 값을 변경할 수 있는 명령어로, 명령어 전체를 순차적으로 모두 처리하는 것이 아니라 코드 일부를 선택적으로 실행할 수 있게 한다. 즉, 실행의 흐름을 변경하거나 어떤 루틴을 호출하는 데 사용한다.
조건 코드를 살펴보고 어떤 조건을 만족할 때만 분기한다. 조건을 만족하지 않으면 프로그램 카운터로 인해 분기 명령어 다음에 위치한 명령어가 실행된다. 이때 분기를 하기 위해서는 조건을 기억해야 하기 때문에 조건을 저장하기 위한 비트가 또 필요하다.

<div align="center">

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdV4LDP%2FbtqEq8ZWYcB%2FPKIgNjM2n1R6XxEz15Khzk%2Fimg.png)

</div>

<br></br>

### 최종 명령어 집합 구성

<div align="center">

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F27oYU%2FbtryV24P88s%2FTnPuWmCvegKeVkfksnF8dK%2Fimg.png)

</div>

'모드'는 2비트를 추가로 차지한다. 이때 모드는 위에서 배운 '주소 지정 모드'이다. 2비트로 4가지 표현이 가능하고, 직접/간접/즉시 주소 지정 모드를 나타낸다.

<br></br>

### 참고 자료

- [059 명령어 형식](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=davidoff73&logNo=30027805588)
- [#4 컴퓨터 구조 - 명령어 형식](https://hyk0425.tistory.com/8)
- [[운영체제] 레지스터란?](http://itnovice1.blogspot.com/2019/08/blog-post_99.html)
- [accumulator; 누산기](http://www.terms.co.kr/accumulator.htm)
- [week4 - 명령어 분류와 형식](https://jeongminhee99.tistory.com/56)
- [[CS] 어떤 것들이 컴퓨터 하드웨어를 구성할까? 컴퓨터 내부 구조](https://techblog-history-younghunjo1.tistory.com/507)

### 마지막 설계

지금까지 살펴본 모든 내용을 모아 실제 컴퓨터를 만들기.  
우리가 사용하는 소프트웨어는 `명령어`와 `데이터`의 집합체이다.

<br/>

### 명령어 레지스터

<br/>

<b>_컴퓨터 기억 장치 종류_</b>

- `SSD`
- `RAM`
- `Cache`
- `Register`

<br/>
<br/>

<b>_CPU 구성 요소_</b>

<p align="center">
<img width="800" alt="스크린샷 2022-06-05 오후 4 50 47" src="https://user-images.githubusercontent.com/80025242/172041533-db158286-f9bc-4052-b366-ff48b72c5993.png">
</p>

- ALU (연산 장치)
- CU (제어 장치)
- Cache (캐시 메모리)
- Register (임시 기억 장치)

<br/>
<br/>

<b>_CPU 동작 과정_</b>

- `CPU`는 `RAM`과 소통합니다. `RAM`은 `SSD`와 소통합니다.
- `SSD`에 비하면 `RAM`이 굉장히 빠르지만, 사실 절대적인 속도 자체는 느리기 때문에 CPU 내부의 `Cache`를 이용해 데이터 이용 속도를 높입니다.
- `Cache`메모리는 `RAM`에 비해 용량이 매우 작기 때문에 중요하다고 생각되는 데이터만 저장해서 사용합니다.

<br/>
<br/>

[ *`Cache`메모리 특징* ]

- L1 Chache / L2 Cache / L3 Cache
- 속도 ▲ 용량 ▼ ------- 속도 ▼ 용량 ▲
- `CPU`는 제일 처음으로 L1 Chache 에서 데이터를 찾습니다.  
   여기 없으면 L2, L3 순차적으로 찾다가 캐시 메모리에서 없으면 그 다음으로 `RAM`에서 데이터를 찾습니다.

<br/>
<br/>

[ *`Register`메모리 특징* ]

- CPU 내부에서 데이터를 일시적으로 저장하는 장치 (속도가 가장 빠른 메모리)
- `Register`종류

  - 프로그램 카운터 : 다음에 수행할 메모리의 주소 저장
  - 메모리 주소 레지스터 : 프로그램 카운터로부터 수행해야하는 주소를 넘겨받아 그 주소를 찾아가 데이터를 가져옴
  - 메모리 버퍼 레지스터 : 메모리 주소 레지스터가 가져온 `데이터`나 `명령`을 일시적으로 저장
  - `명령어 레지스터` : `명령`에 관한 데이터 저장

                    (메모리 버퍼 레지스터에 저장된 내용중 `명령`은 이 명령어 레지스터에 전달됨)

  - `누산기 레지스터` : 연산의 결과값 또는 중간값을 일시적으로 저장

                    (메모리 버퍼 레지스터에 저장된 내용중 (연산에 사용될)`데이터`는 이 누산기 레지스터에 전달됨)

-> 최종 결과는 메모리 버퍼 레지스터를 통해 `메모리`로 전송됩니다.

<br/>
<br/>

[ *`CU`(제어 장치) 특징* ]

- `명령어 레지스터`에 있는 명령어를 받아 해석하고, 해석된 명령을 수행할 시스템에 지시합니다.

<br/>
<br/>

[ *`ALU`(연산 장치) 특징* ]

- 산술 논리 연산 수행 ex. AND, OR, NAND, XOR ...

<br/>
<br/>

<b>_컴퓨터가 코드를 읽는 과정_</b>

<p align="center">
<img width="500" alt="스크린샷 2022-06-05 오후 4 49 59" src="https://user-images.githubusercontent.com/80025242/172041650-8e3f9d29-02db-4591-8d35-994074319e2f.png">
</p>

- 코딩된 언어는 `컴파일러`를 통해 `CPU`가 실행할 수 있는 `어셈블리 언어`로 변환됩니다.
- `어셈블리 언어`는 `어셈블러`를 통해 약속된 규칙에 따라 0과 1로 이루어진 `기계어`로 변환됩니다.

<br/>
<br/>

- 참고 자료

  [CPU는 어떻게 동작할까 ?](https://www.youtube.com/watch?v=Fg00LN30Ezg&t=234s)

# RISC와 CISC 명령어 집합

> ### CISC(Complex Instruction Set Computer)

`Intel`칩으로 대표되는 CISC

1. 복잡한 명령어 집합을 가지고 있다.
2. 명령어의 개수 증가에 따라 프로세서 내부 구조가 매우 복잡해지고, 고속으로 작동되는 프로세서를 만들기 힘듦. (RISC를 탄생시킨 결정적 계기)
3. 주로 메인프레임이나 펜티엄 시리즈와 같은 CISC CPU도 내부적으로 복잡한 명령어들을 단순한 명렁어로 나누어 명령어 파이프라인에서 처리하기 때문에 실제 내부 작동 원리는 RISC와 같음.
   ex) 복잡한 명령어: 메모리 1의 내용 X 메모리 2의 내용 -> 메모리 3에 삽입

<br>

> ### RISC(Reduced Instruction Set Computer)

`ARM` 칩으로 대표되는 RISC

1. CISC에서 실제 쓰이는 명령어가 몇 개 되지 않는다는 사실을 바탕으로, 적은 수의 명령어만으로 명령어 집합을 가지고 있는 CPU 구조.
2. 파이프라이닝 기술을 도입할 수 있어 빠른 동작 속도와 하드웨어 단순화 및 효율화, 가격 경쟁력 우위 등의 장점들을 가짐.
3. RISC는 대부분 현대 프로세서 디자인에 채택되어 있고, 임베디드 프로세서에도 사용됨.

<br>

> ### CISC / RISC 특징

### 1. CISC의 특징

- 명령어의 포맷이나 길이에 관한 규칙이 없음(가변적임)
- Micro-Rom 방식의 명령어 디코딩

  :Micro-Rom(= Microcode-Rom, 기계어를 쉽게 추가할 수 있도록 이용하는 방식)

- 하나 이상의 클럭 주기로 하나의 명령어 실행

### 2. RISC의 특징

- 고정 길이 명령어
- 랜덤 로직 방식의 명령어 디코딩
  : 빠른 프로세스 수행은 가능하지만 복잡한 프로세스들에는 비효율적
- 단일 클럭 프로세싱
  : 파이프라인 프로세싱이라고도 하며 클럭 주기당 하나의 명령어 실행

<br>

> ### CISC VS RISC

|             |                   CISC                   |        RISC        |
| :---------: | :--------------------------------------: | :----------------: |
|    구조     |                   복잡                   |        단순        |
|    구성     |            복잡, 많은 명령어             | 간단, 최소 명령어  |
| 명령어 길이 |                  가변적                  |    고정된 길이     |
|  레지스터   |                   적음                   |        많음        |
|  처리속도   |                   느림                   |        빠름        |
|  전력소모   |                   많음                   |        적음        |
|    용도     | 개인용 컴퓨터 ex) PC 상의 Intel 프로세서 | 서버, 워크스테이션 |

**※ RISC에서 레지스터가 많은 이유: 많은 수의 Register로 메모리 접근을 줄이는 구조이기 때문에**

<img width="717" alt="image" src="https://user-images.githubusercontent.com/91880235/171986070-333b9f9f-4018-461d-bed5-d3d8c9c28cf3.png">

<br>

> ### ETC

### 1. `아키텍쳐 변천사`

- `x86`(범용 CPU, IA-32, 32비트)
- `x64`(범용 CPU, IA-64, 64비트)

- `x86-64`(32비트 호환되는 64비트, AMD64(원조), INTEL64(카피), 현재 대부분의 CPU에 해당)

  -> 기존의 x64(IA-64)는 거의 실패한 구조로, 요즘은 x86-64를 x86라고 통칭하여 부름

- `ARM`(저전력 고효율, 스마트기기와 같은 소형기기에 주로 사용)

- `RISC-V`(차세대 CPU, 개발 중)

<br>

### 2. `RISC-V(RISC Five)`

- 2010년부터 UC버클리에서 개발 중인 RISC 기반 개방형(오픈소스) 명령어 집합(ISA)
- CPU코어를 개발자가 원하는 방향대로 구현할 수 있음.

  다양한 운영체제와 IDE를 지원하고, 임베디드 시스템 설계에 범용으로 사용될 수 있음

- 리눅스 지원(리눅스 5.6 릴리즈 버전에서 RISC V 추가)

<img width="400" alt="image" src="https://user-images.githubusercontent.com/91880235/171985138-1f82aab3-a335-4b03-9d06-3c1871f77e95.png">

<br>

### 3. `EPIC(Explicity Parallel Instruction Computing)`

- 여러 명령어를 병렬로 실행 가능한 CPU 구조.
- Intel에 의해 개발되었고 RISC + VLIW 조합으로 구성됨.
- 분기 예측이 가능하여 파이프라인 해저드 방지.

- 인텔의 `아이테니엄`이 대표적인 EPIC CPU 구조였으나 2021년 단종. IA64 실패의 결과.

_※ VLIW(Very Long Instruction Word)_

_: 여러가지 독립적인 연산 여러개가 하나의 명령어에 들어가 있는 구조._

_※ 파이프라인 해저드_

_: 분기 명령어와 같은 이벤트들이 필요없는 주기들을 생성하여 파이프라인이 중단되는 상태._

<br>

### 4. `Windows 비트 확인 법`

- `내 컴퓨터 정보`에서 확인

<img width="328" alt="image" src="https://user-images.githubusercontent.com/91880235/171985751-8434a711-abd2-4754-bc8c-9213730fa629.png">

### \* Mac OS 비트 확인 법

- 터미널에 `uname-a` 입력
  <img width="483" alt="image" src="https://user-images.githubusercontent.com/91880235/171985851-bd22e484-8e2c-4b53-bd09-fab20ac83a62.png">

<br>

> ### 참고

<hr>

- [RISC 나무위키](https://namu.wiki/w/RISC)
- [CISC 나무위키](https://namu.wiki/w/CISC)
- [[운영체제] 4. CISC와 RISC](https://cooling.tistory.com/19)
- [RISC-V 나무위키](https://namu.wiki/w/RISC-V)
- [x86과 x64의 뜻과 차이 - CPU, OS, S/W](https://blog.naver.com/mumasa/221049608979)
- [RISC-V에 대한 나만의 생각](https://butter-shower.tistory.com/207)
- [RISC-V 구조가 왜 좋은가?](https://www.kernel.bz/boardPost/118681/4)

# GPU

> ### GPU란?
>
> `GPU(graphics processing unit)`는 컴퓨터 시스템에서, 그래픽 연산을 빠르게 처리하여 결과값을 모니터에 출력하는 연산 장치이다. `VPU(visual processing unit)`라고도 한다.

현대의 GPU는 컴퓨터 그래픽과 영상 처리에 매우 효과적으로 사용되며, 고도의 병행 구조는 큰 덩어리의 영상 데이터가 병행 처리되는 알고리즘에 다용도 CPU보다 능률적이다

이 용어는 `엔비디아`에서 `지포스 256`을 `세계 최초의 GPU`로 판매하면서 널리 알려졌다.

<br>

> ### GPU의 탄생

- 기존에는 `CPU`가 `GPU` 역할도 모두 도맡아 함.

  -> 그러나 점점 기술이 발전하면서 GUI(Graphical User Interface) 등의 `다양한 로드가 추가 됨`

  -> 이는 `CPU의 성능 저하(병목 현상)`로 이어짐

  -> 간단한 연산들(ex. 그래픽 작업)은 다른 Processing Unit에게 맡기고 `기존의 중요한 일`만 CPU에게 맡기도록 하자는 아이디어가 나옴

  -> `GPU의 탄생`

<img width="765" alt="image" src="https://user-images.githubusercontent.com/91880235/171986972-9f406d2e-268e-48c9-b455-7c2f14be25f5.png">

<br>

> ### CPU와 GPU의 차이

### CPU

- CPU는 순차적인 처리 방식에 특화
- 코어 수가 비교적 적으며 복잡한 연산을 빠르게 계산 함
- 내부 면적의 절반 이상이 캐시로 채워져
  있기 때문에 GPU에 비해 상대적으로 ALU(Arithmetic
  logic
  unit)가 차지할 수 있는 공간이 적다.

<br>

### GPU

- GPU는 병렬적인 처리 방식에 특화
- CPU에 비해 코어 수가 월등히 많지만, CPU의 개별 코어보다 성능은 낮음

  -> 처리 속도는 명령어나 데이터의 성격에 따라 CPU가 빠를 수도, GPU가 빠를 수도 있다.

<img width="415" alt="image" src="https://user-images.githubusercontent.com/91880235/171986992-1f6809fd-b94f-4d77-abf6-f1b3404570a8.png">
<br>

### CPU와 GPU 처리 속도 차이

<img width="765" alt="image" src="https://user-images.githubusercontent.com/91880235/171986989-9da3396c-9b32-4261-b4a0-3104f5be1d07.png">

[단순한 상수 연산을 수행할 경우]

- CPU: 5.84ms
- GPU: 42.8ms

[행렬 연산 수행(10000 by 10000)]

- CPU: 13.7s
- GPU: 785ms

-> 단순하고 병렬적인 연산은 GPU가 압도적인 처리 속도를 가짐

<br>

> ### 참고

- [GPU 나무위키](https://namu.wiki/w/GPU)
- [그래픽 카드 이야기 (feat. GPGPU, 채굴, 딥러닝, 빅데이터, 3D 모델링, 슈퍼컴퓨터 등) - [高지식] 거니](https://www.youtube.com/watch?v=tsB97IAejbk)
- [CPU와 GPU](https://velog.io/@euisuk-chung/CPU%EC%99%80-GPU)
- [CPU와 GPU의 차이](https://sdc-james.gitbook.io/onebook/2.-1/1./1.1.1.-cpu-gpu)
