# 컴퓨터는 어떤 논리로 비트를 다루는가?

<br/>

사실 '계산'만을 위해 발명된 근본적인 기술은 드물다.  
대부분의 기술은 다른 목적을 위해 만들어진 기술을 `계산`에 `적용`했을 뿐이다.  
이번 장에서는 꽤 최근에 일어난(2019 기준) 전기 분야의 혁신을 이끌어낸 기술 변화를 다룬다.

<br/>

### 학습 목표

- 컴퓨터는 왜 10진수를 사용하지 않고 비트(2진수)를 사용하는가 ?
- 하드 웨어는 어떻게 조합 논리(불리언 대수)를 구현하는가 ?  
  (하드 웨어 = 비트에 대해 동작하는 모든 물리적인 장치)

<br/>
<br/>

# 디지털 컴퓨터의 사례

<br/>

### [근대의 계산 장치]

- <b>톱니 바퀴를 사용한 기계식 컴퓨터</b>  
  : 각 톱니 바퀴의 톱니 비율이 두 바퀴의 상대적인 회전 속도를 결정 -> 곱셈, 나눗셈 등 계산에 유리.

<br/>

1. `안티키테라` 기계 Antikythera.  
: 사용자가 다이얼을 돌려서 날짜를 입력하고 크랭크를 돌려서  
 해당 날짜의 태양의 위치나 달의 위치와 같은 천문학 계산을 수행하는 기계.
<p align="center"><img src="https://github.com/RyanKor/book-review/assets/40455392/6c462ecf-8f55-4eed-8f60-880b9f114147" alt="안티키테라 기계" width="300"/></p>

<br/>

2. `화기 제어 컴퓨터` Fire control computer.  
: 수많은 톱니바퀴를 사용해 삼각함수와 미적분 계산을 수행하는 기계.
<p align="center"><img src="https://i.pinimg.com/1200x/70/81/4a/70814a54c13a43ba973faa1fa41ddb2c.jpg" alt="화기 제어 컴퓨터" width="300"/></p>

<br/>

- <b>톱니 바퀴를 사용하지 않은 기계식 컴퓨터</b>

<br/>

1. `계산자` Slide rule.  
 : 많은 사람에게 최초로 대량 생산된 계산 장치.  
 : log(x \* y) = log(x) + log(y) 라는 사실을 이용해 곱셈을 수행하는 기계.  
 : 계산자로 고정된 x로그 눈금과 움직이는 y로그 눈금의 기준선을 맞추면 두 수의 곱을 구할 수 있다.
<p align="center"><img src="https://github.com/RyanKor/book-review/assets/40455392/bc922ffc-d326-419b-9835-a9e397d86f00" alt="계산자" width="300"></p>

<br/>

### 아날로그와 디지털의 차이

<br/>

[ 계산자 vs 손가락 or 탤리 막대 or 기계식 계산기 ]

<br/>

- 계산자
  : 실수를 표현할 수 있다. -> 수학적으로 연속적이다.  
  : 연속적(continuous) === 아날로그(analog).

<br/>

- 손가락 or 탤리 막대 or 기계식 계산기  
  : 실수를 표현할 수 없다. -> 수학적으로 이산적이다.  
  : 이산적(discrete) === 디지털(digital).  
   (라틴어로 손가락이 digitus)

<br/>

계산자는 실수를 표현할 수 있기 때문에 계산에는 아날로그가 적합해보인다. 그러나 `정밀도`의 문제가 있다!  
계산자 눈금에서 1.1을 선택하기는 쉽지만 9.1을 선택하지는 못한다. 눈금은 정해진 곳에만 표시되어 있기 때문이다.  
자의 크기를 늘리면 9.1을 쉽게 찾을 수도 있겠다. 그러나, 우리는 작고 빠르면서 전력 소모가 적은 컴퓨터를 원한다.

<br/>

### 하드웨어에서 크기가 중요한 이유

<br/>

현대 컴퓨터는 전자를 움직여서 동작한다.  
전기는 빛의 속도로 움직이고, 빛의 속도는 초당 3억 미터다. (미국은 초당 10억 피트)  
이렇게 우리가 넘기 힘든 물리적인 제약이 있기 때문에, 대신 컴퓨터의 부품을 최대한 가깝게 위치시켜서 전자 여행의 속도를 최소화한다.

<br/>

<p align="center"><img src="https://cs.calvin.edu/activities/books/rit/chapter2/design/hardware/cpu/images/pentium4.jpg" alt="CPU" width="300"></p>

<br/>

오늘날 컴퓨터 `clock speed`(클록 속도)는 4GHz이다. === 1초에 40억 가지 계산을 처리할 수 있다.  
(1/40억)초 동안 전자가 이동할 수 있는 거리는 75밀리미터뿐이다!!  
위 그림은 전형적인 CPU의 모습을 보여준다. 이 CPU는 한 면이 18밀리미터다.  
(1/40억)초는 전자가 이 CPU 안을 (겨우) 2번 왕복할 수 있는 정도의 시간이다. 18 _ 4 = 72  
-> _`컴퓨터의 모든 것을 작게 만들면 더 높은 성능을 달성한다 ?!!`\*  
-> 이것이 계산 장치의 역사가 하드웨어를 작게 만드려는 노력으로 점철되어있는 이유중 하나다 ...! 🫢

<br/>

### 디지털을 사용하면 더 안정적인 장치를 만들 수 있다

<br/>

[ 외부적인 간섭 ]

하드웨어를 작게 만들면 속도와 효율은 좋아지지만, 물체가 너무 작아지면 서로 간섭하기가 쉬워진다.  
계산자(연속적인 장치)는 외부적인 조건(ex. 내 시력, 손 흔들림 등)에 의해 결과값이 변할 수 있다.  
그러나 이산적인 장치는 `판정 기준`(decision criteria)이 있기 때문에 외부 조건의 영향을 받지 않는다.  
(손가락으로 숫자를 셀때는 중간이 없는 것 처럼 !!)

<br/>

[ 내부적인 간섭 ]

전자기력은 중력과 마찬가지로 멀리 떨어진 물체에 영향을 끼칠 수 있다.  
이 특성을 통해 라디오 송신같은 좋은 기능도 구현할 수 있지만, CPU칩 내부의 신호가 다른 선에 영향을 끼칠 수도 있다는 말이 된다.  
현대 컴퓨터 칩 안의 선은 몇 나노미터(10^-9) 떨어져 있다. (머리카락 지름이 10만 나노미터인거 감안하면 진짜 어마어마한 숫자 ..)  
칩 내부 선들 간에 발생하는 `crosstalk`(누화 효과)를 방지할 수 있는 적절한 방법이 없기 때문에  
더 높은 `판정 기준`을 통해 `noise immunity`(잡음 내성)을 갖는 디지털 회로를 사용하는 것이 필수적이다 !!

<br/>

📍 `noise immunity`(잡음 내성)이 생기는 이유 ?  
:`판정 기준`이라는 장애물을 뛰어넘기 위해선 추가로 에너지가 필요하기 떄문에  
 연속적인 장치를 사용할 때는 얻을 수 없는 일정 수준의 잡음 내성이 생기게 된다.

<br/>

### 아날로그 세계에서 디지털 만들기

<br/>

수많은 엔지니어들은 (과학자들이 발견한) 자연적으로 발생하는 `transfer function`(전이 함수)을 응용하여 사용한다.  
전이 함수란, 실제 세계에서 벌어지는 현상을 표현한 함수이다.

<br/>

[ 카메라 필름의 전이 함수 ]

<br/>

<p align="center"><img src="https://github.com/RyanKor/book-review/assets/40455392/3b5db1ed-0c48-4192-b346-2a2c15d29a03" alt="카메라 필름 전이 함수 그래프" width="300"></p>

<br/>

x축은 빛이 들어오는 양(입력값)을 뜻하고, y값은 센서가 기록하는 빛(출력값)을 의미한다.  
빛의 곡선이 상단부에 많이 닿으면, 센서에 기록되는 밝기값이 최댓값에 가까워지면서 이미지 노출이 과해진다.  
빛의 곡선이 하단부에 많이 닿으면, 이미지 노출이 부족해진다.  
-> 카메라의 경우는 노출을 조절해서 직선부에 많이 닿게 만드는 것이 목표이다.  
-> 빛을 많이 받아야 현실을 잘 반영하는 이미지를 얻을 수 있기 때문이다.

<br/>

엔지니어들은 빛이 선형 영역에 닿게 하기 위해(원하는대로 구현하기 위해), 여러 장치들을 만들었다.  
ex. 카메라의 셔터 속도나 조리개를 조절하는 장치, 이어폰이나 스피커의 증폭 장치 등

<br/>

[ 스피커의 증폭 전이 함수]

<br/>

<p align="center"><img src="https://images.velog.io/images/ricky0813/post/777dc69f-e100-4048-a876-110b9023ee0d/image.png" alt="증폭 전이 함수" width="300"></p>

<br/>

볼륨은 `gain`(게인)을 조절하거나, 곡선의 가파른 정도를 조정하여 결정된다.  
위 그림을 보면, 게인이 높으면 곡선이 가팔라지고, 출력도 커진다는 것을 알 수 있다.  
그런데 여기서 게인을 최대로 올려버리면 어떻게 될까?

<br/>

<p align="center"><img src="https://images.velog.io/images/ricky0813/post/864b225c-6563-4d7f-90f3-dd3d3195ff2a/image.png" alt="증폭기 클리핑" width="300"></p>

<br/>

위 그림에서 입력이 전이 함수의 선형 영역을 넘어서기 떄문에 (입력값이 최저값과 최고값을 포함하고 있는 모습)  
출력이 더 이상 입력과 비슷하게 흘러가지 않는다.  
-> 이는 마치 한 손가락에서 다른 손가락으로 건너뛰는 것과 같다 !!  
 이때 `판정 기준`을 `threshold`(문턱값)이라고 부른다.  
-> _이 현상은 연속적인 공간을 이산적인 영역으로 나눠준다._  
 _이로부터 우리는 안정성과 잡음 내성을 얻을 수 있다._

<br/>

### 10진 숫자 대신 비트를 사용하는 이유

<br/>

아날로그보다 디지털 기술이 더 나은 이유는 알겠다. 그런데 왜 10진수가 아니라 2진수를 사용할까? 둘 다 디지털 기술인데.

<br/>

<b>📍 하드웨어에서 비트가 숫자보다 좋은 이유</b>

1. 열 손가락은 10가지 숫자밖에 표현하지 못하지만 각 손가락을 비트를 표현하는 데 사용하면 1000개가 넘는 숫자를 표현할 수 있다.  
   즉, 10진수보다 2진수가 100배 이상 효율이 좋다.
2. 10진수를 사용할 때 전이 함수로 각기 다른 10가지 문턱값을 구분하기 어렵다.  
   만들수는 있지만 훨씬 더 복잡하고 비용이 많이 든다.

<br/>
      
<p align="center"><img src="https://images.velog.io/images/ricky0813/post/b5ed6d6d-a061-43bf-9908-6dbb806ccbf9/image.png" alt="10진 문턱값과 2진 문턱값" width="300"></p>
      
<br/>
      
10진 숫자 하나보다는 10비트를 사용하는 편이 훨~씬 낫다.   
전기 엔지니어들은 하단부 영역을 `cutoff`(차단)이라고 부르고, `saturation`(포화)라고 부른다.   
비트를 사용하면 전이 함수가 아주 가파르기때문에 재량권이 아주 커진다. 👍🏻

# 간단한 전기 이론 가이드

### 전기는 수도 배관과 유사하다

전기는 눈에 보이지 않아 시각화 하기 어렵다. 하지만 마치 수도 밸브에 물이 흐르는 것과 유사하게 설명할 수 있다.  
밸브가 열린 상태를 1, 닫힌 상태를 0이라고 표현한다고 가정한다.  
다음과 같이 전기를 `직렬`로 연결하여 `AND`연산을 구현할 수 있다.  
<img width="436" alt="직렬" src="https://user-images.githubusercontent.com/91672778/168456503-e2c82382-b01b-4e3c-bea8-94994476e9a6.png">

만약 다음과 같이 `병렬`로 연결 한다면 `OR`연산을 구현할 수 있다.  
<img width="447" alt="병렬" src="https://user-images.githubusercontent.com/91672778/168456545-faa6ac13-f7c3-4317-bbb0-2987f5176231.png">

- 전파 지연(propagation delay):  
  전기 회로에서 신호가 회로 속을 전파할 때 생기는 지연 시간. 신호값의 변화가 입력에서 출력까지 전달되는 데 걸리는 시간을 나타낸다.  
  샤워기 물 온도를 변화시키기 위해 손잡이를 돌리고 온도가 변할 때 까지 약간의 시간이 걸리는 것으로 경험 할 수 있다.

- 전기 선의 구성  
  전기도 물이 파이프를 따라 흘러가듯이 전기도 선을 통해 이동한다. 전기 선은 다음과 같은 두 부분으로 구성된다. + 도체(conductor):  
   전기 선 내부의 유동성 있는 전자가 가득한 금속  
   물 배관 파이프의 내부 + 부도체(insulator):  
   도체를 둘러싼 바깥쪽 부분  
   물 배관 파이프 자체 + 스위치(switch):  
   전기의 흐름을 제어할 수 있는 장치  
   물의 흐름을 제어하는 밸브 역할

- 옴의 법칙(Ohm's raw)  
  `I=V/R`이라는 관계로 이어진 전압, 전류, 저항 간의 관계  
  아래와 같은 사진으로 설명될 수 있다.
  - 전압(voltage):  
    전기장 안에서 전하가 갖는 전위의 차이, 단위로는 `V`볼트(volt)를 사용  
    물이 파이프 속을 흘러 다닐 수 있게하는 압력같은 역할
  - 전류(current):  
    전하(전기)의 흐름의 양, 단위로는 `A`암페어(ampare)를 사용
  - 저항(resistance):  
    물질이 전류를 방해하는 성질, `Ω`단위로 옴(ohm)을 사용  
    물이 흐르는 밸브가 가늘수록 관에 흐르는 물의 양이 줄어드는 현상  
    전기를 열로 바꾸어 준다. 이를 활용해 전열기구가 작동한다.

<img width="448" alt="옴" src="https://user-images.githubusercontent.com/91672778/168457270-0aa4a97b-8a25-46fa-a21d-48c7bc557d4f.png">

### 전기 스위치

- 회로(circuit):  
  전류가 흐르는 길. 마치 건물의 배관 시스템처럼 물이 흐르는 길과 같은 역할.
- 스키매틱(schematic diagrams):  
  계통도, 또는 회로도로 회로를 문서화한 것을 말한다. 각 구성요소를 기호로 표현한다.

- 극(pole): 한꺼번에 연결되어 이동하는 스위치의 수
- 투(throw): 접점의 개수

![극투](https://user-images.githubusercontent.com/91672778/168457554-4cbbce1d-cd52-4d82-9b8f-33619d643f13.png)

- 단극단투(SPST,single-pole,single-throw): 연결을 하거나 끊는 역할만 가지고 있다.
- 단극쌍투(SPDT,single-pole,double-throw): 한쪽은 켜고 한쪽은 끄는 역할 등 두 접점이 다른 역할을 할 수 있다.
- 쌍극단투(DPST,double-pole,single-throw): 원하는 개수만큼 극과 접점을 사용해 용어를 확장할 수 있다.
- 쌍극쌍투(DPDT,double-pole,double-throw)

![회로](https://user-images.githubusercontent.com/91672778/168457693-e0993626-44c0-4ce5-9ef9-c7d31d31125f.jpeg)  
다음은 전기 회로의 예로 전원에서 출발해 다시 전원의 반대쪽 극으로 돌아올 수 있어야 전기가 흐를 수 있다.  
스위치가 열려있으면 전구가 켜지지 않지만 스위치를 닫으면 전구를 통과해 다시 전원으로 돌아갈 수 있어 전구가 켜진다.

# 릴레이

릴레이(계전기)는 스위치를 움직이기 위해 `전자석`을 사용하는 장치
즉, 스위치 역할을 하는 장치이다.

선을 둥글게 감아서 코일로 만들고 전기를 흘려보내면
코일이 `전자석`이 된다.

<img width="250" alt="image" src="https://user-images.githubusercontent.com/91880235/168411681-ea4d5d9d-23ec-4a54-bb16-d2c1632bc2f6.png">

전자석은 켜고 끌 수 있기 때문에 물건을 움직일 때 이를 활용할 수 있다. 전자석을 사용해 수도 밸브를 제어 등을 할 수 있는데, 자동 스프링클러 시스템이나 자기부상열차 등에 사용된다.

선으로 만든 코일 주변에서 자석을 움직이면 전기가 발생하는데, 발전기가 이런식으로 작동되며, 우리가 사용하는 전기의 대부분은 이런 원리로 얻어진다.

<img width="300" alt="image" src="https://user-images.githubusercontent.com/91880235/168411666-bbfc7ed4-bf68-4c13-99d3-6748820f376d.png">

대부분의 발전소에서는 각기 다른 에너지원을 사용하지만 공통적으로는 터빈의 회전으로 발전기에서 전기를 생산한다.

<br>

### 스위치의 종류

| 제목                             | 설명                                                                                                                 |
| -------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| SPST(Single Pole, Single Throw   | `단극 단투 스위치`라고도 하며, 가장 기본적인 스위치                                                                  |
| SPDT (Single Pole, Double Throw) | `단극 쌍투 스위치`라고도 하며, 3로 스위치로 불리기도 함                                                              |
| DPST (Double Pole, Single Throw) | `쌍극 단투 스위치`라고도 하며, 누전차단기나 배선용 차단기가 이런 종류의 스위치에 속함                                |
| DPDT (Double Pole, Double Throw) | `쌍극 쌍투 스위치`라고도 하며, 모터의 회전방향을 바꾸거나 2개의 모선 중에 1개의 모선을 골라서 전등을 켤 때도 사용 됨 |

<img width="533" alt="image" src="https://user-images.githubusercontent.com/91880235/168423869-7d714b54-c4b8-466c-ab0c-41ae128422d2.png">

릴레이를 사용하면 스위치로는 불가능한 일을 할 수 있다. 예를 들어, 릴레이를 사용하면 NOT 함수를 구현하는 `인버터`를 만들 수 있다. NOT이 없으면 표현 가능한 불리언 연산이 제한된다.

위쪽의 AND 회로에서 나온 출력을 아래쪽 OR 회로의 입력 중 하나를 구동하기 위해 연결할 수 있다. 이런 능력을 활용하면 스위치가 다른 스위치를 제어하게 만들 수 있고, 이에 따라 컴퓨터에 필요한 복잡한 논리를 만들 수 있다.

<img width="250" alt="image" src="https://user-images.githubusercontent.com/91880235/168410410-f54e1a35-4a3d-4143-b7aa-8dc2d9ad3ce1.png">

이를 활용해 코일을 2개만 사용하는 `단극십투 스테퍼 릴레이(stepper relay)`를 예로 들면 코일 하나는 에너지가 들어올 때마다 접점을 다음 위치로 옮긴다.(스텝을 밟는다) 다른 코일은 접점을 최초 위치로 돌려보내서 릴레이를 재설정한다.
다이얼을 사용하던 시절 전화번호를 셀 때, 오래된 핀볼 기계 등에 쓰였다.

### 릴레이의 단점

- 릴레이는 느리고 전기를 많이 소모한다,
- 먼지(또는 벌레)가 스위치 접점에 있으면 제대로 작동하지 않는다.
  (실제로 미국 컴퓨터과학자 그레이스 호퍼가 마크 II에서 발생한 오류를 추적하다가 릴레이에 낀 나방을 발견하면서 `버그(bug)`라는 단어가 유명해졌다.)
- 코일의 전원을 갑자기 끄면 순간적으로 초고압이 발생하고 초고압에서는 공기에서도 전기가 통하는 현상으로 스위치 접점이 마모될 수 있다.

<br>
<br>

# 진공관

<img width="194" alt="image" src="https://user-images.githubusercontent.com/91880235/168410429-657b1428-e37a-4f44-bba0-36968ea8c896.png">

물체를 충분히 가열하면 전자가 튀어나오는 열전자 방출(thermionic emission)
이라는 현상을 기반으로 만들어짐.

- `캐소드`: 진공관 내에서 '투수'와 같은 역할로 전자가 흘러나오는 장소
  - `히터`: 캐소드를 가열
- `애노드`: '포수'역할을 하며 캐소드에서 전자가 흘러들어가는 장소
- `그리드`: '타자'역할을 하며 전자를 쫓아내 애노드에 도착하지 못하도록 한다.

위 세 요소가 모두 들어있는 진공관을 `삼극관(트라이오드)`라 부른다.

<img width="150" alt="image" src="https://user-images.githubusercontent.com/91880235/168410372-277c1a3a-9a12-458f-985a-2bef47962903.png">

### 진공관의 장단점

- 장점
  - 움직이는 부분이 없어서 릴레이보다 훨씬 더 빠름
  - 릴레이에 비해 안정적인 컴퓨터 구성이 가능해짐
- 단점
  - 전구와 마찬가지로 아주 뜨겁고 깨지기 쉽다.

<br>
<br>
<br>

# 트랜지스터

**트랜지스터(transistor)** 는 전송 저항(transfer resistor)의 줄임말로, `존 바딘`, `월리엄 쇼클리`, `월커 브래튼`이라는 사람이 최초로 트랜지스터를 발명하였다.

_TMI: 이 세사람은 벨 연구소 소속으로, 이 중 쇼클리라는 사람이 실리콘밸리 지역에 첫 발을 딛은 사람이다. ([참고: 쇼클리와 8인의 배신자](https://m.science.ytn.co.kr/view.php?s_mcd=0082&key=201711201619102795))_

트랜지스터는 진공관과 비슷하지만 `도체`와 `부도체`를 오가는 `반도체`라는 특별한 물질로 이뤄진 '기판' 또는 '슬랩'위에서 만들어진다. 트랜지스터는 트랜지스터 그림을 실리콘 웨이퍼(얇은 판) 위에 투영해서 현상하는 `광식각(사진석판기술)`이라는 과정을 통해 만들어진다. => 대량생산에 적합

제조공정에는 비소처럼 위험한 물질을 기판 물질의 성질을 변화시키기 위해 기판 위에 얇게 분사하는 도핑 과정이 들어간다. 도핑은 p와 n 유형의 물질으로 이뤄진 영역을 만들어낸다. 트랜지스터를 만들려면 p와 n의 샌드위치를 만들어야 한다.

### 가장 중요한 두 가지 트랜지스터 유형

- 쌍극 접합 트랜지스터(BJT)
- 필드 효과 트랜지스터(FET)

<img width="400" alt="image" src="https://user-images.githubusercontent.com/91880235/168409921-0874e22c-ede1-46a6-9d8d-11081f26cd56.png">

NPN, PNP, N, P채널이라는 용어는 샌드위치 구성 방법을 뜻한다.

- 두 유형은 각각 `게이트`와 `베이스`라는 스위치 손잡이 역할을 하는 것이 있어 스위치와 비슷한 역할을 한다.
- **쌍극 접합 트랜지스터** 에서는 전기가 한 방향으로만 흐를 수 있다.
- FET 기호에서의 작은 틈은 정전기를 사용한다는 사실을 보여주며, 정전기를 사용해 스위치를 움직이는 것과 비슷하다.
- **금속산화물 반도체 전계 효과 트랜지스터(MOSFET, metal-oxide semiconductor filed effect transistor)** 는 FET의 일종으로, 전력 소모가 적기 때문에 현대 컴퓨터 칩에서 가장 널리 쓰이고 있다.
- N과 P채널 MOSFET을 서로 보완하도록 한 쌍으로 묶어서 사용하는 경우가 많은데, 이로부터 `CMOS(complementary metal oxide semiconductor)`라는 말이 나왔다.

<br>
<br>
<br>

# 집적회로

- 트랜지스터를 사용하면서 더 작고, 빠르고, 전력도 적게 소모하는 논리회로를 만들 수 있게 됨.
- 하지만 트랜지스터를 사용하면 AND 함수 같은 간단한 회로를 만들 때 조차도 부품이 너무 많이 필요하다.

`집적회로(IC, Integrated Circuit)`는 복잡한 시스템을 트랜지스터 하나를 만드는 정도의 비용으로 만들 수 있다. 집적 회로는 생긴 모양 때문에 `칩(chip)`이라고도 불린다.

<img width="200" alt="image" src="https://user-images.githubusercontent.com/91880235/168410140-fd5aa4f0-725a-4e3c-b804-82aaaac7ad4f.png">

똑같은 유형의 회로를 릴레이, 진공관, 트랜지스터, 집적회로를 통해 만들 수 있다.

새로운 기술이 나올 때마다 회로는 더 작아지고 더 저렴해지고 에너지를 더 효율적으로 사용하게 됐다.

집적회로는 전자공학에 혁명을 일으켰고 오늘날 거의 모든 전자장비에 사용된다. 현대사회에서 필수불가결한 컴퓨터, 휴대폰 그리고 다른 모든 가전기기들은 싼 가격의 집적회로 덕분에 가능한 것들이다.

<img width="300" alt="image" src="https://user-images.githubusercontent.com/91880235/168410186-c7a024dd-9e82-4801-8725-1ab3e8e5c9af.png">

### 참고

- [스위치의 종류](https://blog.daum.net/zayouin/7658566)
- [전자 기기의 혁명을 일으킨 집적회로](https://www.scienceall.com/%EC%A0%84%EC%9E%90-%EA%B8%B0%EA%B8%B0%EC%9D%98-%ED%98%81%EB%AA%85%EC%9D%84-%EC%9D%BC%EC%9C%BC%ED%82%A8-%EC%A7%91%EC%A0%81%ED%9A%8C%EB%A1%9C/)
- [릴레이란](https://teacher-camel.tistory.com/63)

# 논리게이트

1960년대 중반에 논리 연산을 수행하는 회로(논리 게이트)가 내장된 5400과 7400 집적 회로(IC) 패밀리가 발표되었다. 아래와 같은 게이트를 활용하면 IC를 선으로 연결해 복잡한 회로를 쉽게 만들 수 있다.

<div align="center">

![](https://i2.wp.com/downrg.com/wp-content/uploads/1/6497748443.jpg?fit=290%2C543)

</div>

[TTL](https://ko.jf-parede.pt/what-is-transistor-transistor-logic-its-working)이든 [CMOS](https://gdnn.tistory.com/89)든 논리 게이트에서 가장 단순한 회로는 `NAND`나 `NOR`이다. 드모르간의 법칙에 의해 AND와 OR 회로를 포현할 수 있고, AND나 OR 회로보다 표현할 수 있는 논리도 더 많다.

<br></br>

### 이력 현상을 활용한 잡음 내성 향상

`이력 현상(hysteresis)`을 사용해 글리치를 방지할 수 있다. 작은 오류를 뜻하는 `글리치`란, 잡음으로 인해 입력 신호가 문턱 값을 여러 번 오락가락하는 것을 말한다. 또한, 이력 현상은 어떠한 물리적 상태, 물리량이 물리적 조건만으로 만들어지는 것이 아니라, 물질이 이전에 겪어온 변화과정에 의존하여(history-dependent) 일어나는 모든 현상을 말하며, 여기서는 판정 기준이 과거의 이력에 따라 달라진다는 뜻이다.
올라가는 신호와 내려가는 신호에 대한 전이 함수와 문턱 값이 다르다면, 반대 쪽 문턱 값을 지나 출력이 반전되기 위해(잡음) 값이 더 크게 변해야 하기 때문에 잡음 내성이 더 커진다고 할 수 있다.

<br></br>

### 차동 신호

`차동신호(Differential signal)`는 두 개의 전송선 위에 위상이 서로 반대로 흐르는 신호를 말한다. 2개의 신호를 쓰는 이유는 잡음에 대해 영향을 받지 않기 위함이다. 외부 잡음은 2개의 신호에 모두 동일한 영향을 미치게 되고, 공통 모드 신호 제거(common-mode rejection)에 의해 잡음을 상쇄한다.

<br></br>

### 전파 지연

`전파 지연(propagation delay)`은 입력의 변화가 출력에 영향을 미칠 때까지 걸리는 시간을 뜻한다. 게이트에는 최대 지연과 최소 지연이 있고 실제 지연은 이 사이의 값이다. 전파 지연은 논리 회로의 최대 속도를 제한하는 요소 중 하나이기 때문에 최악의 경우에 해당하는 지연 시간을 가정하고 회로를 설계한다.

<br></br>

### 출력 유형

위와 같이 입력 과정에서 발생할 수 있는 일들도 있지만 출력에도 몇 가지 유형이 있다.
<br></br>

> 토템폴 출력

일반적인 게이트 출력이다. 토템폴 출력에서 스위치는 출력의 1을 얻기 위해 출력과 높은 논릿값 1을 연결하기 때문에 `액티브 풀업(active pull-up)`이라고 불린다.

<div align="center">

![](https://mblogthumb-phinf.pstatic.net/MjAyMDA1MzFfMTE2/MDAxNTkwOTIyNTE5NDEw.pm75KwevjCOTFIpGsaZye1hAWBzzHWKWGfgkb-Q-Fokg.9K4STXUYceIp9tRo0AFCl5XRllWs1kOBJmVQ7F1qOFUg.PNG.3lastbaek5/image.png?type=w800)

</div>

<br></br>

> 오픈 컬렉터 출력

오픈 컬렉터나 오픈 드레인 버전은 필요 시 출력을 `패시브 풀업(passive pull-up)`에 연결할 수 있다. 패시브 풀업은 풀업 저항을 논리적인 1 값을 공급해주는 공급 전압에 연결한 것이다. 오픈 컬렉터와 패시브 풀업을 사용하면 `와이어드 AND(wired-AND)`를 만들 수 있다.

<br></br>

> 트라이스테이트 출력

<div align="center">

![](https://mblogthumb-phinf.pstatic.net/MjAxOTA2MTZfNDEg/MDAxNTYwNjM3OTI2MzQ1.kNgck8TEyamb8CkS0KhUF_irG2iKsiqlc6LE853-mOwg.BtDs8KC0EMjns874xivFZxd1Tf_rS12VSW9mtZJKx_Ag.PNG.cni1577/image.png?type=w800)

</div>

`트라이스테이트(tri-state) 출력`은 상태가 3가지이다. 입력과 출력 외 `활성화`라는 입력이 존재한다. 오픈 컬렉터 회로를 사용하면 출력을 서로 연결할 수 있지만 액티브 풀업을 사용하는 것만큼 응답이 빠르지는 않기 때문에 트라이스테이트 출력을 사용하기도 한다. 장치들을 서로 선으로 직접 연결할 수는 있지만 한 번에 하나의 장치만 활성화해야 한다는 단점이 있다.
활성화 상태가 꺼진 상태를 `hi-Z`라고도 하며, Z는 저항을 나타내는 `Inpendence`를 뜻한다. 베이스를 제어하면 0, 1, hi-Z, meltdown이라는 4가지 상태를 얻을 수 있다.

<br></br>

### 참고 자료

- [트랜지스터 트랜지스터 로직 (TTL) 및 그 작동 원리](https://ko.jf-parede.pt/what-is-transistor-transistor-logic-its-working)
- [[CMOS] CMOS란?](https://gdnn.tistory.com/89)
- [차동신호란??](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=crashfor&logNo=20109664935)
- [오픈 컬렉터 출력의 장단점](https://gangsanilee.tistory.com/1897)

# 게이트를 조합한 복잡한 회로

게이트를 사용하면서 하드웨어의 설계 과정이 단순해졌다.

**7400 IC**

- 소규모 집적회로 (SSI: small-scale integration) 안에 네가지 NAND 게이트를 제공
- 이 패키지 하나로 40개의 개별 부품을 대체할 수 있다.
  (개별 부품 10개로 입력 2개인 NAND 게이트를 설계할 수 있다.)

- 그저 개별 부품을 사용하는 것보다 더 싸고, 더 작게 원하는 시스템을 만들 수 있다.

이 외에도 게이트의 조합 중 특히 자주 사용되는 조합이 있다.

- **중간 규모 집적 회로** (MSI: medium-scale integration)
- **대규모 집적 회로** (LSI: large-scale integration)
- **초대규모 집적 회로** (VLSI: very large-scale integration)

이렇게 게이트의 조합을 사용해 필요한 부품 수를 줄일 수 있다.
혹은 게이트의 조합으로 만든 고수준의 기본 기능 요소를 사용해 더 고수준의 부품을 만들 수 있다.

<br />

## 가산기

#### 반가산기

2의 보수 가산기를 만든다.
61p에서 두 비트의 합은 각 비트의 XOR, 올림은 두 비트의 AND라는 것을 배웠다.
이를 게이트로 구현하면 아래와 같다.

![반가산기](https://github.com/RyanKor/book-review/assets/40455392/bb39a12b-d6a0-41dc-8864-d91a8bf55165)

AND 게이트 하나와 XOR 게이트 하나로 이루어짐을 알 수 있다. 이를 반가산기(half adder)라고 부른다. 이렇게 두 비트를 더할 때는 반가산기로도 충분하다.

<br />

#### 전가산기

그러나 반가산기는 다른 자리에서 올라오는 올림을 처리할 수 없다. 이를 위해 세 번째 입력이 필요하다. 세 입력 중 2개 이상이 1일 때 올림이 발생한다. 이를 고려한 것이 전가산기이다.

![전가산기](https://github.com/RyanKor/book-review/assets/40455392/ecdc68e3-21fb-4c8e-b7af-da2c140e876f)

**합**: C XOR (A XOR B)
**올림**: (A AND B) OR (A AND C) OR (B AND C)

**전가산기 진리표**
| A | B | C | 합 | 올림 |
|---|---|---|---|------|
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 0 |
| 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | 1 |
| 1 | 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 |

그림을 보면 더 많은 게이트가 필요하지만, 반가산기를 2개 사용하는 것보다 시간 지연이 적고, 더 나은 회로를 만들 수 있다.

<br />

#### 리플 자리올림 가산기

![리플 자리올림 가산기](https://github.com/RyanKor/book-review/assets/40455392/2512ff6c-909c-40e8-aa16-e7a7665dffb6)

전가산기로 여러 비트를 더하는 가산기를 만들 수 있다. 리플 자리올림 계산기는 전가산기를 여러개 이어붙인 형태인데, 자리올림이 아래쪽 비트로 부터 위쪽 비트로 물결이 퍼져나가는 것처럼 전달된다.
아래 비트로 부터 자리 올림수 출력을 받아야 하기 때문에, 비트 하나를 처리할 때마다, 게이트 2개에 해당하는 출력 시간 지연이 발생한다. 이러한 점은 32비트, 64비트 가산기를 만들면 (비트가 커질수록) 지연 시간이 더 커지게 된다.

<br />

#### 올림 예측 가산기 (carry look-ahead-adder)

올림 예측 가산기에서 모든 자리 올림수 출력은 예측 논리에 따라 한 번에 계산된다.

```java

// 129p - 올림 예측이 어떻게 동작하는가?

C2 = (A1 AND B1)OR(A1 AND C1)OR(B1 AND C1)

// C3를 계산하려면 C2가 필요하다.
C3 = (A2 AND B2)OR(A2 AND C2)OR(B2 AND C2)

// C2 자리에 첫 번째 식을 대입
C3 = (A2 AND B2)
    OR(A2 AND (A1 AND B1)OR(A1 AND C1)OR(B1 AND C1))
    OR(B2 AND (A1 AND B1)OR(A1 AND C1)OR(B1 AND C1))

```

이를 이용해 의존 관계를 줄일 수 있고, 지연을 한 번에 없앨 수 있다.

- AND와 OR 연산이 많아지지만, 전파 지연이 최대 2 게이트에 해당한다.
- Cn은 A와 B의 입력에 따라 결정된다.
- 올림 계산 시간이 비트 개수에 따라 달라지지 않고, 덧셈에 걸리는 시간이 일정한 수준으로 고정된다.

<br />

## 디코더 (decoder)

디코더는 인코딩 된 수를 개별 비트의 집합으로 만들어준다.

**닉시 튜브 (nixie tube)**

- 각기 다른 숫자를 표시하는 네온 사인의 모음
- 4비트 2진수를 10가지 각기 다른 출력으로 만들 수 있다.

**3:8 디코더**

- 8진 표현에서, 8진 숫자(3비트)를 단일 비트의 집합으로 되돌려준다.

  ![3:8 디코더](https://github.com/RyanKor/book-review/assets/40455392/75ce293c-84c9-43db-9336-66fc7971c0e0)

**3:8 디코더 진리표**

| S0  | S1  | S2  |     | Y7  | Y6  | Y5  | Y4  | Y3  | Y2  | Y1  | Y0  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   |     | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   |
| 0   | 0   | 1   |     | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 0   |
| 0   | 1   | 0   |     | 0   | 0   | 0   | 0   | 0   | 1   | 0   | 0   |
| 0   | 1   | 1   |     | 0   | 0   | 0   | 0   | 1   | 0   | 0   | 0   |
| 1   | 0   | 0   |     | 0   | 0   | 0   | 1   | 0   | 0   | 0   | 0   |
| 1   | 0   | 1   |     | 0   | 0   | 1   | 0   | 0   | 0   | 0   | 0   |
| 1   | 1   | 0   |     | 0   | 1   | 0   | 0   | 0   | 0   | 0   | 0   |
| 1   | 1   | 1   |     | 1   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |

이러한 동작이 모든 3비트 조합에 대해 성립한다.
이 때 입력이 3개, 출력이 8개이므로 3:8 디코더이다.
(입력이 2개일 때 출력은 2^2 = 4개이며, 이는 2:4 디코더라고 한다.)

<br />

## 디멀티플렉서 (demultiplexer, 디먹스(demux))

입력을 몇 가지 출력 중 한 곳으로 전달한다.

![디멀티플렉서](https://github.com/RyanKor/book-review/assets/40455392/e363b186-bf47-41a7-98f5-8d1efce70203)

D: 입력 신호
S0~S1: 디코더 입력
Y0~3: 출력

디먹스는 D를 디코더의 입력에 따라 네 가지 출력 중 하나로 전달한다.

![디먹스 스키매틱 기호](https://github.com/RyanKor/book-review/assets/40455392/23983a10-f9c4-40b4-9edb-922c3de1e483)

## 실렉터 (selecor, 멀티 플렉서(multiplexer), 먹스 (mux))

디코더에 게이트를 추가해 실렉터를 만들 수 있다.

![실렉터 스키매틱 기호](https://github.com/RyanKor/book-review/assets/40455392/80d7149d-874c-4e17-b46d-9c3c9e329101)

디먹스를 뒤집은 모양이다.
예를 들면, 다이얼에서 눈금 꺼짐, 토스트, 베이크, 브로일이라는 기호가 들어있는 토스트 오븐이 있을 때, 이 다이얼은 실렉터 스위치(selector switch)이다.

**토스터 오븐의 논리표**
|설정 | 위 열선(S0) | 아래 열선(S1) |
|--|--|--|
|끔(D0) | 끔 (0)| 끔 (0)|
|베이크(D1) | 끔 (0)| 켬 (1)|
|토스트(D2) | 끔 (0) |켬 (1)|
|브로일(D3) | 켬 (1)| 끔 (0)|
