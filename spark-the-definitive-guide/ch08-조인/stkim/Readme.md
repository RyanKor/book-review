# 조인

- 스파크 클러스터에서 어떻게 조인을 수행하는가?

## 1. 조인 표현식

- 왼쪽 <-> 오른쪽 지정된 키가 같은지 확인하는 동등 조인(equal-join)

## 2. 조인 타입

- 내부 조인(inner join): 왼쪽과 오른쪽 데이터셋에 키가 있는 로우를 유지
- 외부 조인(outer join): 왼쪽이나 오른쪽 데이터셋에 키가 있는 로우를 유지
- 왼쪽 외부 조인(left outer join): 왼쪽 데이터셋에 키가 있는 로우를 유지
- 오른쪽 외부 조인(right outer join): 오른쪽 데이터셋에 키가 있는 로우를 유지
- 왼쪽 세미 조인(left semi join): 왼쪽 데이터셋의 키가 오른쪽 데이터셋에 있는 경우에는 키가 일치하는 왼쪽 데이터셋만 유지
- 왼쪽 안티 조인(left anti join): 왼쪽 데이터셋의 키가 오른쪽 데이터셋에 없는 경우에는 키가 일치하지 않는 왼쪽 데이터셋만 유지
- 자연 조인(natural join): 두 데이터셋에서 동일한 이름을 가진 컬럼을 암시적(implicit)으로 결합하는 조인을 수행
- 교차 조인(cross join) 또는 카테시안 조인(Cartesian join): 왼쪽 데이터셋의 모든 로우와 오른쪽 데이터셋의 모든 로우를 조합

## 3. 내부 조인

- 스파크에서 내부 조인은 DataFrame or Table에 있는 키를 평가 후, `참으로 평가되는 로우만` 결합함.

## 4. 외부 조인

- 스파크에서 내부 조인은 DataFrame or Table에 있는 키를 평가 후, `참 또는 거짓으로 평가되는 로우만` 결합함.
- 일치하는 로우 값이 없는 경우 NULL로 표시됩니다.

## 5. 왼쪽 외부 조인

- 왼쪽 데이터셋에 있는 모든 행을 유지하며, 오른쪽 데이터셋에 매칭되지 않는 로우 있으면 NULL

## 6. 오른쪽 외부 조인

- 오른쪽 데이터셋에 있는 모든 행을 유지하며, 왼쪽 데이터셋에 매칭되지 않는 로우 있으면 NULL

## 7. 왼쪽 세미 조인

- 왼쪽 데이터셋의 키가 오른쪽 데이터셋에 있는 경우에만, 왼쪽 데이터셋의 행을 유지

- 오른쪽 DataFrame의 어떤 값도 포함시키지 않음.

- DataFrame의 필터 느낌으로 사용함. (사실 잘 이해가 안됨)

## 8. 왼쪽 안티 조인

- 왼쪽 세미 조인의 반대 개념.

- 왼쪽 데이터셋의 키가 오른쪽 데이터셋에 없는 경우에만, 왼쪽 데이터셋의 행을 유지

- SQL의 `NOT IN`의 개념

## 9. 자연 조인(natural join)

- 두 데이터셋에서 동일한 이름의 컬럼을 기준으로 `암시적`으로 조인

- 암시적으로 조인하는 것은 무척 위험함. 부정확한 결과로 이어질 수 있음.

## 10. 교차 조인(cross join) 또는 카테시안 조인(Cartesian join)

- 왼쪽 데이터셋의 모든 행과 오른쪽 데이터셋의 모든 행을 조합하여 결과를 생성

- 데이터가 기하급수적으로 많아질 수 있어, 사용할 때 조심해야함.

## 11. 조인 시 문제점

### 11.1 복잡한 타입의 데이터 조인
- 불리언 타입을 반환하는 모든 표현식이 조인 표현식으로 간주될 수 있음

### 11.2 중복 컬럼명 처리
- 해결 방법 1: 다른 조인 표현식 사용
- 해결 방법 2: 조인 후 컬럼 제거
- 해결 방법 3: 조인 전 컬럼 명 변경

## 12. 스파크의 조인 수행 방식 (개인적으로 좀 더 파보면 좋을 것으로 보이는 파트)

- 조인에 필요한 스파크의 두 가지 핵심 전략

    - 노드 간 네트워크 통신 전략

    - 노드 별 연산 전략

### 12.1 노드 간 네트워크 통신 전략

- 전체 노드 통신을 요구하는 셔플

- 그렇지 않은 브로드캐스트 조인

#### 12.1.1 두개의 큰 테이블 조인 프로세스
![두 개의 큰 테이블 조인 프로세스](https://github.com/user-attachments/assets/5932bb56-613a-4cae-aaaf-10bb57da93ca)

- 큰 테이블끼리 조인하면 셔플 조인 발생 
- 즉, 전체 노드에 대해 통신을 요구하는 연산 발생 -> 네트워크 & 연산 비용 무척 큼.
- 여기에 데이터도 잘 분산되어 있지 않으면 연산 비용은 더 크게 증가함.

#### 12.1.2 큰 테이블과 작은 테이블 조인 프로세스

![큰 테이블과 작은 테이블 조인 프로세스](https://github.com/user-attachments/assets/39ddc3a4-9d24-4c66-9fe2-479e8e0c17a0)

- 이 경우, 브로드 캐스트 조인 권장 (테이블이 단일 워커 노드에서 수행되기에 적합한 정도라면)

- 대규모 노드 통신은 발생하지만, 이후 추가적인 통신이 발생하지 않음

- 참고로 너무 큰 연산 비용 발생하면 드라이버가 뻗음

#### 12.1.3 작은 테이블끼리 조인 프로세스

- 그냥 스파크가 알아서하게 두면됨

- 브로드캐스트 수행됨.