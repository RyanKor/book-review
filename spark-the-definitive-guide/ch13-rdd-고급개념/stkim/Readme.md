# Chpater 13. RDD 고급 개념

## 스파크에서 RDD를 사용해야만하는 상황 리마인드

- 복잡한 데이터 구조 처리: 고수준 API에서 제공하지 않는 타입의 복잡한 데이터를 처리하고자할 때

- 정밀한 데이터 작업을 요구할 때: 마찬가지로 고수준 API만으로 제어하기 어려운 데이터를 처리할 때 필요

- 기존 코드가 RDD로 되어 있을 때: 호환성을 해치지 않기 위해 사용

## 13장 전체에서 다루고자하는 데이터 : key-value 포맷의 데이터

- key-value 형태의 데이터를 사용하겠다는 것은 곧 시간 복잡도 (`Big O - Time Complexity`)를 줄이고, 메모리를 많이 사용해서 공간 복잡도(`Space Complexity`)를 사용하겠다는 것.

- 왜 복잡한 형태의 데이터로써 RDD 고급 개념에서 언급되었을까?

    - 책 후반부에 언급되는 핫키(Hot Key)와 같이 데이터 쏠림은 문자열이나 정수형 등의 원시 타입으로 처리하기 어려운 데이터에 대한 연산이 필요함.

    - 데이터에 대한 병렬처리를 엑시큐터에서 실행하고나면 일부 메서드들 (collect, take, count 등)의 집계 함수들은 드라이버로 데이터를 다시 주는데, 이 과정에서 OOM이 많이 발생.

        - 즉, RDD로 키를 어떻게 분산해서 파티셔닝할 수 있는가? (shuffle?)

        - 셔플을 모든 노드에서 발생하게 할 것인지, 연산할 데이터를 줄여줄 것인지에 사용하기 나름?

- key-value 포맷의 데이터를 다룰 때 `<메서드명>ByKey`를 사용할 수 있고, 이 때 PairRDD라는 데이터 타입만 사용이 가능함.

    - keyBy, sampleByKey, counyByKey

    - 문제는 executor에서 데이터를 연산하기 전 데이터에 대한 모든 정보를 메모리에 읽어야하는데 (드라이버로 강력하게 추정), 여기서 OOM이 발생할 여지가 다분함.

        - 최근 혜율님이 처리했던 데이터도 비슷한 이슈로 추정.